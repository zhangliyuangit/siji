/*
 Navicat Premium Data Transfer

 Source Server         : 本地
 Source Server Type    : MySQL
 Source Server Version : 80019
 Source Host           : localhost:3306
 Source Schema         : siji

 Target Server Type    : MySQL
 Target Server Version : 80019
 File Encoding         : 65001

 Date: 30/04/2021 11:06:00
*/

SET NAMES utf8mb4;
SET FOREIGN_KEY_CHECKS = 0;

-- ----------------------------
-- Table structure for s_answer
-- ----------------------------
DROP TABLE IF EXISTS `s_answer`;
CREATE TABLE `s_answer`  (
  `id` int(0) NOT NULL AUTO_INCREMENT COMMENT 'id',
  `user_id` int(0) NOT NULL COMMENT '用户id',
  `create_time` datetime(0) NULL DEFAULT NULL COMMENT '创建时间',
  `context` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '评论内容',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 1 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of s_answer
-- ----------------------------

-- ----------------------------
-- Table structure for s_article
-- ----------------------------
DROP TABLE IF EXISTS `s_article`;
CREATE TABLE `s_article`  (
  `id` int(0) NOT NULL AUTO_INCREMENT COMMENT 'id',
  `title` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '文章标题',
  `context` text CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '文章内容',
  `create_time` datetime(0) NULL DEFAULT NULL COMMENT '创建时间',
  `thematic` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT '题图',
  `user_id` int(0) NOT NULL COMMENT '用户id',
  `overview` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT '概述',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 29 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of s_article
-- ----------------------------
INSERT INTO `s_article` VALUES (1, 'RabbitMQ', '## RabbitMQ\r\n\r\n### MQ引言\r\n\r\n\r\n\r\n#### 什么是MQ\r\n\r\nMQ(Message Queue)消息队列，通过典型的**生产者**和**消费者**模型，生产者不断向消息队列中生产消息，消费者不断从队列中获取消息。因为消息的生产和消费都是异步的，而且只关心消息的发送和接收，没有业务逻辑的侵入，轻松的实现系统间解耦。别名为**消息中间件**通过利用高效可靠的消息传递机制进行平台无关的数据交流，并基于数据通信来进行分布式系统的集成。\r\n\r\n\r\n\r\n#### MQ有哪些\r\n\r\n当今市面上有很多主流的消息中间件，如老牌的`ActiveMQ`、`RabbitMQ`，炙手可热的`Kafka`，阿里巴巴自主开发`RocketMQ`等。\r\n\r\n\r\n\r\n#### 不同MQ的特点\r\n\r\n```markdown\r\n# 1.ActiveMQ\r\n		ActiveMQ 是Apache出品，最流行的，能力强劲的开源消息总线。它是一个完全支持JMS规范的的消息中间件。丰富的API,多种集群架构模式让ActiveMQ在业界成为老牌的消息中间件,在中小型企业颇受欢迎!\r\n\r\n# 2.Kafka\r\n		Kafka是LinkedIn开源的分布式发布-订阅消息系统，目前归属于Apache顶级项目。Kafka主要特点是基于Pull的模式来处理消息消费，追求高吞吐量，一开始的目的就是用于日志收集和传输。0.8版本开始支持复制，不支持事务，对消息的重复、丢失、错误没有严格要求，适合产生大量数据的互联网服务的数据收集业务。\r\n\r\n# 3.RocketMQ\r\n		RocketMQ是阿里开源的消息中间件，它是纯Java开发，具有高吞吐量、高可用性、适合大规模分布式系统应用的特点。RocketMQ思路起源于Kafka，但并不是Kafka的一个Copy，它对消息的可靠传输及事务性做了优化，目前在阿里集团被广泛应用于交易、充值、流计算、消息推送、日志流式处理、binglog分发等场景。\r\n\r\n# 4.RabbitMQ\r\n		RabbitMQ是使用Erlang语言开发的开源消息队列系统，基于AMQP协议来实现。AMQP的主要特征是面向消息、队列、路由（包括点对点和发布/订阅）、可靠性、安全。AMQP协议更多用在企业系统内对数据一致性、稳定性和可靠性要求很高的场景，对性能和吞吐量的要求还在\r\n```\r\n\r\n> RabbitMQ比Kafka可靠，Kafka更适合高吞吐的处理，一般应用在大数据日志处理或者对实时性(少量延迟)，可靠性(少量丢数据)要求稍低的场景使用，比如ELK日志收集。\r\n\r\n\r\n\r\n\r\n\r\n### RabbitMQ引言\r\n\r\n> 基于`AMQP`协议，使用erlang开发，是部署最广泛消息中间件，是最受欢迎的开源消息中间件之一。\r\n\r\n\r\n\r\n```markdown\r\n # AMQP 协议\r\n 		AMQP（advanced message queuing protocol）`在2003年时被提出，最早用于解决金融领不同平台之间的消息传递交互问题。顾名思义，AMQP是一种协议，更准确的说是一种binary wire-level protocol（链接协议）。这是其和JMS的本质差别，AMQP不从API层进行限定，而是直接定义网络交换的数据格式。这使得实现了AMQP的provider天然性就是跨平台的。以下是AMQP协议模型:\r\n```\r\n\r\n![](https://cdn.jsdelivr.net/gh/zhangliyuangit/img/image-20200311182438041.png)\r\n\r\n\r\n\r\n#### RabbitMQ支持的消息模型\r\n\r\n![](https://cdn.jsdelivr.net/gh/zhangliyuangit/img/image-20191126165434784.png)\r\n\r\n\r\n\r\n### RabbitMQ配置\r\n\r\n\r\n\r\n#### 使用安装包安装\r\n\r\n```markdown\r\n# 1.将rabbitmq安装包上传到linux系统中\r\n	erlang-22.0.7-1.el7.x86_64.rpm\r\n	rabbitmq-server-3.7.18-1.el7.noarch.rpm\r\n\r\n# 2.安装Erlang依赖包\r\n	rpm -ivh erlang-22.0.7-1.el7.x86_64.rpm\r\n\r\n# 3.安装RabbitMQ安装包(需要联网)\r\n	yum install -y rabbitmq-server-3.7.18-1.el7.noarch.rpm\r\n		注意:默认安装完成后配置文件模板在:/usr/share/doc/rabbitmq-server-3.7.18/rabbitmq.config.example目录中,需要	\r\n				将配置文件复制到/etc/rabbitmq/目录中,并修改名称为rabbitmq.config\r\n# 4.复制配置文件\r\n	cp /usr/share/doc/rabbitmq-server-3.7.18/rabbitmq.config.example /etc/rabbitmq/rabbitmq.config\r\n\r\n# 5.查看配置文件位置\r\n	ls /etc/rabbitmq/rabbitmq.config\r\n\r\n# 6.修改配置文件(参见下图:)\r\n	vim /etc/rabbitmq/rabbitmq.config \r\n```\r\n\r\n![](https://cdn.jsdelivr.net/gh/zhangliyuangit/img/image-20190925222230260-3836271.png)\r\n\r\n将上图中配置文件中红色部分去掉`%%`,以及最后的`,`逗号 修改为下图:\r\n\r\n![](https://cdn.jsdelivr.net/gh/zhangliyuangit/img/image-20190925222329200-3836312.png)\r\n\r\n```markdown\r\n# 7.执行如下命令,启动rabbitmq中的插件管理\r\n	rabbitmq-plugins enable rabbitmq_management\r\n	\r\n	出现如下说明:\r\n		Enabling plugins on node rabbit@localhost:\r\n    rabbitmq_management\r\n    The following plugins have been configured:\r\n      rabbitmq_management\r\n      rabbitmq_management_agent\r\n      rabbitmq_web_dispatch\r\n    Applying plugin configuration to rabbit@localhost...\r\n    The following plugins have been enabled:\r\n      rabbitmq_management\r\n      rabbitmq_management_agent\r\n      rabbitmq_web_dispatch\r\n\r\n    set 3 plugins.\r\n    Offline change; changes will take effect at broker restart.\r\n\r\n# 8.启动RabbitMQ的服务\r\n	systemctl start rabbitmq-server\r\n	systemctl restart rabbitmq-server\r\n	systemctl stop rabbitmq-server\r\n	\r\n\r\n# 9.查看服务状态(见下图:)\r\n	systemctl status rabbitmq-server\r\n  ● rabbitmq-server.service - RabbitMQ broker\r\n     Loaded: loaded (/usr/lib/systemd/system/rabbitmq-server.service; disabled; vendor preset: disabled)\r\n     Active: active (running) since 三 2019-09-25 22:26:35 CST; 7s ago\r\n   Main PID: 2904 (beam.smp)\r\n     Status: \"Initialized\"\r\n     CGroup: /system.slice/rabbitmq-server.service\r\n             ├─2904 /usr/lib64/erlang/erts-10.4.4/bin/beam.smp -W w -A 64 -MBas ageffcbf -MHas ageffcbf -\r\n             MBlmbcs...\r\n             ├─3220 erl_child_setup 32768\r\n             ├─3243 inet_gethost 4\r\n             └─3244 inet_gethost 4\r\n      .........\r\n```\r\n\r\n![](https://cdn.jsdelivr.net/gh/zhangliyuangit/img/image-20190925222743776-3836511.png)\r\n\r\n```markdown\r\n# 10.关闭防火墙服务\r\n	systemctl disable firewalld\r\n    Removed symlink /etc/systemd/system/multi-user.target.wants/firewalld.service.\r\n    Removed symlink /etc/systemd/system/dbus-org.fedoraproject.FirewallD1.service.\r\n	systemctl stop firewalld   \r\n\r\n# 11.访问web管理界面\r\n	http://10.15.0.8:15672/\r\n```\r\n\r\n\r\n\r\n#### 使用Docker启动\r\n\r\n```shell\r\ndocker run -d --hostname rabbit-host --name rabbitmq -e RABBITMQ_DEFAULT_USER=root -e RABBITMQ_DEFAULT_PASS=root -p 15672:15672 -p 5672:5672 rabbitmq:3-management\r\n```\r\n\r\n\r\n\r\n#### 命令行管理\r\n\r\n```markdown\r\n# 1.服务启动相关\r\n	systemctl start|restart|stop|status rabbitmq-server\r\n\r\n# 2.管理命令行  用来在不使用web管理界面情况下命令操作RabbitMQ\r\n	rabbitmqctl  help  可以查看更多命令\r\n\r\n# 3.插件管理命令行\r\n	rabbitmq-plugins enable|list|disable \r\n```\r\n\r\n\r\n\r\n#### web界面介绍\r\n\r\n![](https://cdn.jsdelivr.net/gh/zhangliyuangit/img/image-20191126162026720.png)\r\n\r\n- `connections：无论生产者还是消费者，都需要与RabbitMQ建立连接后才可以完成消息的生产和消费，在这里可以查看连接情况`\r\n- `channels：通道，建立连接后，会形成通道，消息的投递获取依赖通道。`\r\n- `Exchanges：交换机，用来实现消息的路由`\r\n- `Queues：队列，即消息队列，消息存放在队列中，等待消费，消费后被移除队列。`\r\n\r\n\r\n\r\n#### 创建虚拟主机\r\n\r\n```markdown\r\n# 虚拟主机\r\n	为了让各个用户可以互不干扰的工作，RabbitMQ添加了虚拟主机（Virtual Hosts）的概念。其实就是一个独立的访问路径，不同用户使用不同路径，各自有自己的队列、交换机，互相不会影响。\r\n```\r\n\r\n![](https://cdn.jsdelivr.net/gh/zhangliyuangit/img/image-20191126163023153.png)\r\n\r\n\r\n\r\n#### 绑定虚拟主机和用户\r\n\r\n创建好虚拟主机，我们还要给用户添加访问权限：\r\n\r\n点击添加好的虚拟主机：\r\n\r\n![](https://cdn.jsdelivr.net/gh/zhangliyuangit/img/image-20191126163506795.png)\r\n\r\n进入虚拟机设置界面:\r\n\r\n![](https://cdn.jsdelivr.net/gh/zhangliyuangit/img/image-20191126163631889.png)\r\n\r\n\r\n\r\n### HelloWord版本\r\n\r\n#### 引入依赖\r\n\r\n```xml\r\n<dependency>\r\n  <groupId>com.rabbitmq</groupId>\r\n  <artifactId>amqp-client</artifactId>\r\n  <version>5.9.0</version>\r\n</dependency>\r\n```\r\n\r\n#### 第一种模型(直连)\r\n\r\n![image-20191126165840602](RibbitMQ 实战教程.assets/image-20191126165840602.png)\r\n\r\n\r\n\r\n在上图的模型中，有以下概念：\r\n\r\n- P：生产者，也就是要发送消息的程序\r\n- C：消费者：消息的接受者，会一直等待消息到来。\r\n- queue：消息队列，图中红色部分。类似一个邮箱，可以缓存消息；生产者向其中投递消息，消费者从其中取出消息。\r\n\r\n\r\n\r\n#### 创建一个生产者\r\n\r\n```java\r\npublic class ProducerDemo {\r\n    @Test\r\n    public void test() throws IOException, TimeoutException {\r\n        //创建连接工厂\r\n        ConnectionFactory connectionFactory = new ConnectionFactory();\r\n\r\n        //设置mq主机\r\n        connectionFactory.setHost(\"121.196.147.102\");\r\n        //设置端口\r\n        connectionFactory.setPort(5672);\r\n        //设置用户名和密码\r\n        connectionFactory.setUsername(\"root\");\r\n        connectionFactory.setPassword(\"root\");\r\n        //设置连接那个虚拟主机\r\n        connectionFactory.setVirtualHost(\"/zhang\");\r\n\r\n        //获取连接对象\r\n        Connection connection = connectionFactory.newConnection();\r\n\r\n        //获取连接中的通道\r\n        Channel channel = connection.createChannel();\r\n        //参数1：是否持久化 参数2：是否独占队列 参数3：是否自动删除 参数4：其他属性\r\n        channel.queueDeclare(\"hello\",false,false,false,null);\r\n\r\n        /*\r\n        发布消息\r\n        参数1 交换机名称\r\n        参数2 队列名称\r\n        参数3 传递额外消息设置\r\n        参数4 消息的具体内容\r\n         */\r\n        channel.basicPublish(\"\",\"hello\",null,\"hello world\".getBytes());\r\n        channel.close();\r\n        connection.close();\r\n    }\r\n}\r\n```\r\n\r\n![](https://cdn.jsdelivr.net/gh/zhangliyuangit/img/image-20210114200534153.png)\r\n\r\n#### 创建一个消费者\r\n\r\n这里我们使用main方法来进行测试，因为如果我们使用junit进行测试的话，可能接收不到消息。(因为可能我们的测试线程退出之前我们并没有拿到队列中的消息)\r\n\r\n```java\r\npublic class ConsumerDemo {\r\n    public static void main(String[] args) throws IOException, TimeoutException {\r\n\r\n        //创建连接工厂\r\n        ConnectionFactory connectionFactory = new ConnectionFactory();\r\n\r\n        connectionFactory.setHost(\"121.196.147.102\");\r\n        connectionFactory.setPort(5672);\r\n        connectionFactory.setVirtualHost(\"/zhang\");\r\n        connectionFactory.setUsername(\"root\");\r\n        connectionFactory.setPassword(\"root\");\r\n\r\n        Connection connection = connectionFactory.newConnection();\r\n        //创建通道\r\n        Channel channel = connection.createChannel();\r\n\r\n        //通道绑定队列\r\n        channel.queueDeclare(\"hello\",false,false,false,null);\r\n\r\n        //消费消息\r\n        /*\r\n        参数1 队列的名称\r\n        参数2 开启消息的自动确认机制\r\n        参数3 消费消息时的回调接口\r\n         */\r\n        channel.basicConsume(\"hello\",true,new DefaultConsumer(channel){\r\n            /**\r\n             * @param consumerTag\r\n             * @param envelope\r\n             * @param properties\r\n             * @param body 消息队列中取出的消息\r\n             * @throws IOException\r\n             */\r\n            @Override\r\n            public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException {\r\n                System.out.println(new String(body));\r\n            }\r\n        });\r\n\r\n        //channel.close();\r\n        //connection.close();\r\n    }\r\n}\r\n```\r\n\r\n\r\n\r\n#### 参数说明\r\n\r\n```java\r\nchannel.queueDeclare(\"aaa\",true,false,false,null);\r\n```\r\n\r\n- 第一个参数队列名称\r\n\r\n- 第二个参数通道是否持久化\r\n\r\n开启之后\r\n\r\n![image-20210114215219767](https://cdn.jsdelivr.net/gh/zhangliyuangit/img/image-20210114215219767.png)\r\n\r\n重启rabbitmq服务 hello通道会丢失，而aaa通道不会丢失(但是消息会丢失)。\r\n\r\n想让消息不丢失可以在`channel.basicPublish(\"\",\"aaa\", MessageProperties.PERSISTENT_TEXT_PLAIN,\"hello world\".getBytes());`添加MessageProperties.PERSISTENT_TEXT_PLAIN，这样rabbitmq在服务关闭时就会把消息特通道持久化到硬盘中，重启时会把消息和队列进行恢复。\r\n\r\n\r\n\r\n- 第三个参数表示是否独占队列\r\n\r\n如果设置为true， 队列只能被当前通道所绑定，不能被其他通道绑定。如果有其他通道绑定会抛出错误。\r\n\r\n- 第四个参数表示是否自动删除\r\n\r\n被消费完后，队列没有其他消息是否自动删除。\r\n\r\n\r\n\r\n### WorkQueue版本\r\n\r\n`Work queues`，也被称为（`Task queues`），任务模型。当消息处理比较耗时的时候，可能生产消息的速度会远远大于消息的消费速度。长此以往，消息就会堆积越来越多，无法及时处理。此时就可以使用work 模型：**让多个消费者绑定到一个队列，共同消费队列中的消息**。队列中的消息一旦消费，就会消失，因此任务是不会被重复执行的。\r\n\r\n![](https://cdn.jsdelivr.net/gh/zhangliyuangit/img/image-20200314221002008.png)\r\n\r\n角色：\r\n\r\n- P：生产者：任务的发布者\r\n- C1：消费者-1，领取任务并且完成任务，假设完成速度较慢\r\n- C2：消费者-2：领取任务并完成任务，假设完成速度快\r\n\r\n\r\n\r\n#### 开发生产者\r\n\r\n```java\r\n//通过通道声明队列\r\nchannel.queueDeclare(\"work\", true, false, false, null);\r\n\r\n//生产消息\r\nfor (int i = 0; i < 10; i++) {\r\n    channel.basicPublish(\"\",\"work\",null,\"hello workqueue\".getBytes());\r\n}\r\n```\r\n\r\n#### 开发消费者(两个)\r\n\r\n```java\r\nChannel channel = connection.createChannel();\r\nchannel.queueDeclare(\"work\",true,false,false,null);\r\nchannel.basicConsume(\"work\",true,new DefaultConsumer(channel) {\r\n    @lombok.SneakyThrows\r\n    @Override\r\n    public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException {\r\n        System.out.println(\"消费者-1：\" + new String(body));\r\n        Thread.sleep(1000);\r\n    }\r\n});\r\n```\r\n\r\n\r\n\r\n#### 测试结果\r\n\r\n![](https://cdn.jsdelivr.net/gh/zhangliyuangit/img/image-20200314223242058.png)\r\n\r\n![](https://cdn.jsdelivr.net/gh/zhangliyuangit/img/image-20200314223302207.png)\r\n\r\n> 总结：RabbitMQ默认情况下，会轮询消息给每个消费者，每个消费者都会收到相同数量的消息。\r\n\r\n但是这并不是我们想要的，我们需要处理快的消费者多处理消息。\r\n\r\n\r\n\r\n#### 消息自动确认\r\n\r\n> Doing a task can take a few seconds. You may wonder what happens if one of the consumers starts a long task and dies with it only partly done. With our current code, once RabbitMQ delivers a message to the consumer it immediately marks it for deletion. In this case, if you kill a worker we will lose the message it was just processing. We\'ll also lose all the messages that were dispatched to this particular worker but were not yet handled.\r\n>\r\n> But we don\'t want to lose any tasks. If a worker dies, we\'d like the task to be delivered to another worker.\r\n\r\n```java\r\nchannel.basicQos(1);//一次只接受一条未确认的消息\r\n//参数2:关闭自动确认消息\r\nchannel.basicConsume(\"hello\",false,new DefaultConsumer(channel){\r\n  @Override\r\n  public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException {\r\n    System.out.println(\"消费者1: \"+new String(body));\r\n    channel.basicAck(envelope.getDeliveryTag(),false);//手动确认消息\r\n  }\r\n});\r\n```\r\n\r\n- 设置通道一次只能消费一个消息\r\n\r\n- 关闭消息的自动确认,开启手动确认消息\r\n\r\n\r\n\r\n### Fanout版本\r\n\r\n`fanout 扇出 也称为广播`\r\n\r\n ![image-20191126213115873](C:/Users/49572/Desktop/RibbitMQ 实战教程.assets/image-20191126213115873.png)\r\n\r\n在广播模式下，消息发送流程是这样的：\r\n\r\n-  可以有多个消费者\r\n-  每个**消费者有自己的queue**（队列）\r\n-  每个**队列都要绑定到Exchange**（交换机）\r\n-  **生产者发送的消息，只能发送到交换机**，交换机来决定要发给哪个队列，生产者无法决定。\r\n-  交换机把消息发送给绑定过的所有队列\r\n-  队列的消费者都能拿到消息。实现一条消息被多个消费者消费\r\n\r\n#### 开发生产者\r\n\r\n```java\r\n//声明交换机\r\nchannel.exchangeDeclare(\"logs\",\"fanout\");//广播 一条消息多个消费者同时消费\r\n//发布消息\r\nchannel.basicPublish(\"logs\",\"\",null,\"hello\".getBytes());\r\n```\r\n\r\n\r\n\r\n#### 开发消费者-1\r\n\r\n```java\r\n//绑定交换机\r\nchannel.exchangeDeclare(\"logs\",\"fanout\");\r\n//创建临时队列\r\nString queue = channel.queueDeclare().getQueue();\r\n//将临时队列绑定exchange\r\nchannel.queueBind(queue,\"logs\",\"\");\r\n//处理消息\r\nchannel.basicConsume(queue,true,new DefaultConsumer(channel){\r\n  @Override\r\n  public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException {\r\n    System.out.println(\"消费者1: \"+new String(body));\r\n  }\r\n});\r\n```\r\n\r\n我们同时开发三个消费者。代码相同\r\n\r\n\r\n\r\n#### 测试结果\r\n\r\n![](https://cdn.jsdelivr.net/gh/zhangliyuangit/img/image-20200315180653207.png)\r\n\r\n![](https://cdn.jsdelivr.net/gh/zhangliyuangit/img/image-20200315180708489.png)\r\n\r\n![](https://cdn.jsdelivr.net/gh/zhangliyuangit/img/image-20200315180728035.png)\r\n\r\n我们可以看到三个消费者都接收到了消息。\r\n\r\n\r\n\r\n### Routing版本\r\n\r\n> 在Fanout模式中，一条消息，会被所有订阅者队列都消费。但是，在某些场景下，我们希望不同的消息被不同的队列所消费。这是我们就要用到Direct类型的交换机。\r\n\r\n 在Direct模型下：\r\n\r\n- 队列与交换机的绑定，不能是任意绑定了，而是要指定一个`RoutingKey`（路由key）\r\n- 消息的发送方在 向 Exchange发送消息时，也必须指定消息的 `RoutingKey`。\r\n- Exchange不再把消息交给每一个绑定的队列，而是根据消息的`Routing Key`进行判断，只有队列的`Routingkey`与消息的 `Routing key`完全一致，才会接收到消息\r\n\r\n![](https://cdn.jsdelivr.net/gh/zhangliyuangit/img/image-20191126220145375.png)\r\n\r\n图解：\r\n\r\n- P：生产者，向Exchange发送消息，发送消息时，会指定一个routing key。\r\n- X：Exchange（交换机），接收生产者的消息，然后把消息递交给 与routing key完全匹配的队列\r\n- C1：消费者，其所在队列指定了需要routing key 为 error 的消息\r\n- C2：消费者，其所在队列指定了需要routing key 为 info、error、warning 的消息\r\n\r\n#### 1.开发生产者\r\n\r\n```java\r\n//声明交换机  参数1:交换机名称 参数2:交换机类型 基于指令的Routing key转发\r\nchannel.exchangeDeclare(\"logs_direct\",\"direct\");\r\nString key = \"\";\r\n//发布消息\r\nchannel.basicPublish(\"logs_direct\",key,null,(\"指定的route key\"+key+\"的消息\").getBytes());\r\n```\r\n\r\n#### 2.开发消费者-1\r\n\r\n```java\r\n //声明交换机\r\nchannel.exchangeDeclare(\"logs_direct\",\"direct\");\r\n//创建临时队列\r\nString queue = channel.queueDeclare().getQueue();\r\n//绑定队列和交换机\r\nchannel.queueBind(queue,\"logs_direct\",\"error\");\r\nchannel.queueBind(queue,\"logs_direct\",\"info\");\r\nchannel.queueBind(queue,\"logs_direct\",\"warn\");\r\n\r\n//消费消息\r\nchannel.basicConsume(queue,true,new DefaultConsumer(channel){\r\n  @Override\r\n  public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException {\r\n    System.out.println(\"消费者1: \"+new String(body));\r\n  }\r\n});\r\n```\r\n\r\n#### 3.开发消费者-2\r\n\r\n```java\r\n//声明交换机\r\nchannel.exchangeDeclare(\"logs_direct\",\"direct\");\r\n//创建临时队列\r\nString queue = channel.queueDeclare().getQueue();\r\n//绑定队列和交换机\r\nchannel.queueBind(queue,\"logs_direct\",\"error\");\r\n//消费消息\r\nchannel.basicConsume(queue,true,new DefaultConsumer(channel){\r\n  @Override\r\n  public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException {\r\n    System.out.println(\"消费者2: \"+new String(body));\r\n  }\r\n});\r\n```\r\n\r\n####  4.测试生产者发送Route key为error的消息时\r\n\r\n![](https://cdn.jsdelivr.net/gh/zhangliyuangit/img/image-20200316102627912.png)\r\n\r\n#### 5.测试生产者发送Route key为info的消息时\r\n\r\n![](https://cdn.jsdelivr.net/gh/zhangliyuangit/img/image-20200316102925740.png)\r\n\r\n![](https://cdn.jsdelivr.net/gh/zhangliyuangit/img/image-20200316102947326.png)\r\n\r\n\r\n\r\n### Topic版本\r\n\r\n`Topic`类型的`Exchange`与`Direct`相比，都是可以根据`RoutingKey`把消息路由到不同的队列。只不过`Topic`类型`Exchange`可以让队列在绑定`Routing key` 的时候使用通配符！这种模型`Routingkey` 一般都是由一个或多个单词组成，多个单词之间以”.”分割，例如： `item.insert`\r\n\r\n![](https://cdn.jsdelivr.net/gh/zhangliyuangit/img/image-20191127121900255.png)\r\n\r\n```markdown\r\n# 统配符\r\n		* (star) can substitute for exactly one word.    匹配不多不少恰好1个词\r\n		# (hash) can substitute for zero or more words.  匹配一个或多个词\r\n# 如:\r\n		audit.#    匹配audit.irs.corporate或者 audit.irs 等\r\n    audit.*   只能匹配 audit.irs\r\n```\r\n\r\n#### 1.开发生产者\r\n\r\n```java\r\n//生命交换机和交换机类型 topic 使用动态路由(通配符方式)\r\nchannel.exchangeDeclare(\"topics\",\"topic\");\r\nString routekey = \"user.save\";//动态路由key\r\n//发布消息\r\nchannel.basicPublish(\"topics\",routekey,null,(\"这是路由中的动态订阅模型,route key: [\"+routekey+\"]\").getBytes());\r\n```\r\n\r\n#### 2.开发消费者-1 \r\n\r\n`Routing Key中使用*通配符方式`\r\n\r\n```java\r\n //声明交换机\r\nchannel.exchangeDeclare(\"topics\",\"topic\");\r\n//创建临时队列\r\nString queue = channel.queueDeclare().getQueue();\r\n//绑定队列与交换机并设置获取交换机中动态路由\r\nchannel.queueBind(queue,\"topics\",\"user.*\");\r\n\r\n//消费消息\r\nchannel.basicConsume(queue,true,new DefaultConsumer(channel){\r\n  @Override\r\n  public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException {\r\n    System.out.println(\"消费者1: \"+new String(body));\r\n  }\r\n});\r\n```\r\n\r\n#### 3.开发消费者-2\r\n\r\n`Routing Key中使用#通配符方式`\r\n\r\n```java\r\n//声明交换机\r\nchannel.exchangeDeclare(\"topics\",\"topic\");\r\n//创建临时队列\r\nString queue = channel.queueDeclare().getQueue();\r\n//绑定队列与交换机并设置获取交换机中动态路由\r\nchannel.queueBind(queue,\"topics\",\"user.#\");\r\n\r\n//消费消息\r\nchannel.basicConsume(queue,true,new DefaultConsumer(channel){\r\n  @Override\r\n  public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException {\r\n    System.out.println(\"消费者2: \"+new String(body));\r\n  }\r\n});\r\n```\r\n\r\n\r\n\r\n\r\n\r\n### SpringBoot整合RabbitMQ\r\n\r\n\r\n\r\n#### HelloWorld\r\n\r\n##### 0.依赖\r\n\r\n```xml\r\n<dependency>\r\n  <groupId>org.springframework.boot</groupId>\r\n  <artifactId>spring-boot-starter-amqp</artifactId>\r\n</dependency>\r\n```\r\n\r\n\r\n\r\n##### 1.编写配置文件\r\n\r\n```yaml\r\nspring:\r\n  application:\r\n    name: rabbitmq-springboot\r\n  rabbitmq:\r\n    host: 121.196.147.102\r\n    port: 5672\r\n    username: root\r\n    password: root\r\n    virtual-host: /zhang\r\n```\r\n\r\n\r\n\r\n##### 2.编写生产者\r\n\r\n```java\r\n/**\r\n * @author liyuan.zhang\r\n * @date 2021/1/17 10:00\r\n */\r\n@SpringBootTest\r\npublic class RabbitMQTest {\r\n\r\n    @Autowired\r\n    private RabbitTemplate rabbitTemplate;\r\n\r\n    @Test\r\n    public void test(){\r\n        rabbitTemplate.convertAndSend(\"hello\",\"hello rabbitmq\");\r\n    }\r\n}\r\n```\r\n\r\n`RabbitTemplate`  用来简化操作     使用时候直接在项目中注入即可使用，使用`convertAndSend`方法直接发送消息。\r\n\r\n\r\n\r\n##### 3.编写消费者\r\n\r\n```java\r\n/**\r\n * @author liyuan.zhang\r\n * @date 2021/1/17 10:02\r\n */\r\n@Component\r\n//默认 持久化  非独占  不自动删除队列\r\n@RabbitListener(queuesToDeclare = @Queue(value = \"hello\",declare = \"true\"))\r\npublic class HelloCustomer {\r\n\r\n    @RabbitHandler\r\n    public void receivel(String message){\r\n        System.out.println(\"message=\" + message);\r\n    }\r\n}\r\n```\r\n\r\n`@Queue`注解可以指定队列的属性，默认持久化，非独占队列，不自动删除队列\r\n\r\n\r\n\r\n#### WorkQueue\r\n\r\n##### 1.编写生产者\r\n\r\n```java\r\n@Test\r\n    public void testWork(){\r\n        for (int i = 0; i < 10; i++) {\r\n            rabbitTemplate.convertAndSend(\"work\",\"hello rabbitmq - work\" + i);\r\n        }\r\n    }\r\n```\r\n\r\n##### 2.编写消费者\r\n\r\n```java\r\n@Component\r\npublic class WorkCustomer {\r\n\r\n    /**\r\n     * 消费者1\r\n     * @param message\r\n     */\r\n    @RabbitListener(queuesToDeclare = @Queue(value = \"work\"))\r\n    public void receivel1(String message){\r\n        System.out.println(\"messgae1:\" + message );\r\n    }\r\n\r\n    @RabbitListener(queuesToDeclare = @Queue(value = \"work\"))\r\n    public void receivel2(String message){\r\n        System.out.println(\"message2:\" + message);\r\n    }\r\n}\r\n```\r\n\r\n> 说明:默认在Spring AMQP实现中Work这种方式就是公平调度,如果需要实现能者多劳需要额外配置\r\n\r\n\r\n\r\n#### Fanout\r\n\r\n##### 1.开发生产者\r\n\r\n```java\r\n//广播模式\r\n@Test\r\npublic void testFanout(){\r\n    rabbitTemplate.convertAndSend(\"logs\",\"\",\"hello rabbitmq - fanout\");\r\n}\r\n```\r\n\r\n##### 2.开发消费者\r\n\r\n```java\r\n/**\r\n * @author liyuan.zhang\r\n * @date 2021/1/17 10:50\r\n */\r\n@Component\r\npublic class FanoutCustomer {\r\n\r\n    @RabbitListener(bindings = {\r\n            @QueueBinding(\r\n                    value = @Queue,//不指定名称为创建临时队列\r\n                    exchange = @Exchange(value = \"logs\",type = \"fanout\")//绑定交换机\r\n            )\r\n    })\r\n    public void receive1(String message){\r\n        System.out.println(\"message1 : \" + message);\r\n    }\r\n\r\n    @RabbitListener(bindings = {\r\n            @QueueBinding(\r\n                    value = @Queue,//不指定名称为创建临时队列\r\n                    exchange = @Exchange(value = \"logs\",type = \"fanout\")//绑定交换机\r\n            )\r\n    })\r\n    public void receive2(String message){\r\n        System.out.println(\"message2 : \" + message);\r\n    }\r\n}\r\n```\r\n\r\n\r\n\r\n#### Route\r\n\r\n##### 1.开发生产者\r\n\r\n```java\r\n//路由模式\r\n@Test\r\npublic void testRoute(){\r\n    rabbitTemplate.convertAndSend(\"directs\",\"info\",\"hello rabbitmq - direct\");\r\n}\r\n```\r\n\r\n\r\n\r\n##### 2.开发消费者\r\n\r\n```java\r\n/**\r\n * @author liyuan.zhang\r\n * @date 2021/1/17 11:00\r\n */\r\n@Component\r\npublic class RouteCustomer {\r\n\r\n    @RabbitListener(bindings = {\r\n            @QueueBinding(\r\n                    value = @Queue,//声明临时队列\r\n                    exchange = @Exchange(value = \"directs\",type = \"direct\"),\r\n                    key = {\"error\",\"info\",\"warning\"}\r\n            )\r\n    })\r\n    public void receive1(String message){\r\n        System.out.println(\"message1 : \" + message);\r\n    }\r\n\r\n    @RabbitListener(bindings = {\r\n            @QueueBinding(\r\n                    value = @Queue,\r\n                    exchange = @Exchange(value = \"directs\",type = \"direct\"),\r\n                    key = {\"error\"}\r\n            )\r\n    })\r\n    public void receive2(String message){\r\n        System.out.println(\"message2 :\" + message);\r\n    }\r\n}\r\n```\r\n\r\n\r\n\r\n#### Topic\r\n\r\n动态路由\r\n\r\n##### 1.开发生产者\r\n\r\n```java\r\n//topic 动态路由  订阅模式\r\n@Test\r\npublic void testTopic(){\r\n    String routeKey = \"product.save\";\r\n    rabbitTemplate.convertAndSend(\"topics\",routeKey,\"要执行的业务是 : \" + routeKey);\r\n}\r\n```\r\n\r\n\r\n\r\n##### 2.开发消费者\r\n\r\n```java\r\n/**\r\n * @author liyuan.zhang\r\n * @date 2021/1/17 11:18\r\n */\r\n@Component\r\npublic class TopicCustomer {\r\n\r\n    @RabbitListener(bindings = {\r\n            @QueueBinding(\r\n                    value = @Queue,\r\n                    exchange = @Exchange(value = \"topics\",type = \"topic\"),\r\n                    key = {\"user.#\"}\r\n            )\r\n    })\r\n    public void receive1(String message){\r\n        System.out.println(\"message1 :\" + message);\r\n    }\r\n\r\n\r\n    @RabbitListener(bindings = {\r\n            @QueueBinding(\r\n                    value = @Queue,\r\n                    exchange = @Exchange(value = \"topics\",type = \"topic\"),\r\n                    key = {\"product.*\",\"user.*\"}\r\n            )\r\n    })\r\n    public void receive2(String message){\r\n        System.out.println(\"message2 :\" + message);\r\n    }\r\n}\r\n```\r\n\r\n\r\n\r\n### RabbitMQ的使用场景\r\n\r\n#### 异步处理\r\n\r\n`场景说明：用户注册后，需要发注册邮件和注册短信,传统的做法有两种 1.串行的方式 2.并行的方式`\r\n\r\n- `串行方式:` 将注册信息写入数据库后,发送注册邮件,再发送注册短信,以上三个任务全部完成后才返回给客户端。 这有一个问题是,邮件,短信并不是必须的,它只是一个通知,而这种做法让客户端等待没有必要等待的东西. \r\n\r\n![](https://cdn.jsdelivr.net/gh/zhangliyuangit/img/SouthEast-4860248.png)\r\n\r\n- `并行方式: `将注册信息写入数据库后,发送邮件的同时,发送短信,以上三个任务完成后,返回给客户端,并行的方式能提高处理的时间。\r\n\r\n![](https://cdn.jsdelivr.net/gh/zhangliyuangit/img/SouthEast-20191127211112660.png)\r\n\r\n- `消息队列:`假设三个业务节点分别使用50ms,串行方式使用时间150ms,并行使用时间100ms。虽然并行已经提高的处理时间,但是,前面说过,邮件和短信对我正常的使用网站没有任何影响，客户端没有必要等着其发送完成才显示注册成功,应该是写入数据库后就返回.  `消息队列`: 引入消息队列后，把发送邮件,短信不是必须的业务逻辑异步处理 \r\n\r\n![](https://cdn.jsdelivr.net/gh/zhangliyuangit/img/592892-20190520220249900-1679743651.jpg)\r\n\r\n由此可以看出,引入消息队列后，用户的响应时间就等于写入数据库的时间+写入消息队列的时间(可以忽略不计),引入消息队列后处理后,响应时间是串行的3倍,是并行的2倍。\r\n\r\n\r\n\r\n#### 应用解耦\r\n\r\n`场景：双11是购物狂节,用户下单后,订单系统需要通知库存系统,传统的做法就是订单系统调用库存系统的接口. `\r\n\r\n![](https://cdn.jsdelivr.net/gh/zhangliyuangit/img/SouthEast-20191127211247287.png)\r\n\r\n这种做法有一个缺点:\r\n\r\n当库存系统出现故障时,订单就会失败。 订单系统和库存系统高耦合.  引入消息队列 \r\n\r\n![](https://cdn.jsdelivr.net/gh/zhangliyuangit/img/SouthEast-20191127211304085.png)\r\n\r\n- `订单系统:`用户下单后,订单系统完成持久化处理,将消息写入消息队列,返回用户订单下单成功。\r\n\r\n- `库存系统:`订阅下单的消息,获取下单消息,进行库操作。  就算库存系统出现故障,消息队列也能保证消息的可靠投递,不会导致消息丢失.\r\n\r\n\r\n\r\n#### 流量削峰\r\n\r\n`场景:` 秒杀活动，一般会因为流量过大，导致应用挂掉,为了解决这个问题，一般在应用前端加入消息队列。  \r\n\r\n  `作用:` \r\n\r\n​			1.可以控制活动人数，超过此一定阀值的订单直接丢弃(我为什么秒杀一次都没有成功过呢^^) \r\n\r\n​			2.可以缓解短时间的高流量压垮应用(应用程序按自己的最大处理能力获取订单) \r\n\r\n![](https://cdn.jsdelivr.net/gh/zhangliyuangit/img/20210117155050.png)\r\n\r\n1.用户的请求,服务器收到之后,首先写入消息队列,加入消息队列长度超过最大值,则直接抛弃用户请求或跳转到错误页面.  \r\n\r\n2.秒杀业务根据消息队列中的请求信息，再做后续处理.\r\n\r\n\r\n\r\n### RabbitMQ搭建集群环境\r\n\r\n#### 7.1.1 普通集群(副本集群)\r\n\r\n> All data/state required for the operation of a RabbitMQ broker is replicated across all nodes. An exception to this are message queues, which by default reside on one node, though they are visible and reachable from all nodes. To replicate queues across nodes in a cluster   --摘自官网\r\n\r\n`默认情况下:RabbitMQ代理操作所需的所有数据/状态都将跨所有节点复制。这方面的一个例外是消息队列，默认情况下，消息队列位于一个节点上，尽管它们可以从所有节点看到和访问`\r\n\r\n1. ##### 架构图\r\n\r\n![image-20200320094147471](C:/Users/49572/Desktop/RibbitMQ 实战教程.assets/image-20200320094147471.png)\r\n\r\n​	核心解决问题:  `当集群中某一时刻master节点宕机,可以对Quene中信息,进行备份`\r\n\r\n2. ##### 集群搭建\r\n\r\n   ```markdown\r\n   # 0.集群规划\r\n   	node1: 10.15.0.3  mq1  master 主节点\r\n   	node2: 10.15.0.4  mq2  repl1  副本节点\r\n   	node3: 10.15.0.5  mq3  repl2  副本节点\r\n   \r\n   # 1.克隆三台机器主机名和ip映射\r\n   	vim /etc/hosts加入:\r\n   		 10.15.0.3 mq1\r\n       	10.15.0.4 mq2\r\n       	10.15.0.5 mq3\r\n   	node1: vim /etc/hostname 加入:  mq1\r\n   	node2: vim /etc/hostname 加入:  mq2\r\n   	node3: vim /etc/hostname 加入:  mq3\r\n   \r\n   # 2.三个机器安装rabbitmq,并同步cookie文件,在node1上执行:\r\n   	scp /var/lib/rabbitmq/.erlang.cookie root@mq2:/var/lib/rabbitmq/\r\n   	scp /var/lib/rabbitmq/.erlang.cookie root@mq3:/var/lib/rabbitmq/\r\n   \r\n   # 3.查看cookie是否一致:\r\n   	node1: cat /var/lib/rabbitmq/.erlang.cookie \r\n   	node2: cat /var/lib/rabbitmq/.erlang.cookie \r\n   	node3: cat /var/lib/rabbitmq/.erlang.cookie \r\n   \r\n   # 4.后台启动rabbitmq所有节点执行如下命令,启动成功访问管理界面:\r\n   	rabbitmq-server -detached \r\n   \r\n   # 5.在node2和node3执行加入集群命令:\r\n   	1.关闭       rabbitmqctl stop_app\r\n   	2.加入集群    rabbitmqctl join_cluster rabbit@mq1\r\n   	3.启动服务    rabbitmqctl start_app\r\n   \r\n   # 6.查看集群状态,任意节点执行:\r\n   	rabbitmqctl cluster_status\r\n   \r\n   # 7.如果出现如下显示,集群搭建成功:\r\n   	Cluster status of node rabbit@mq3 ...\r\n   	[{nodes,[{disc,[rabbit@mq1,rabbit@mq2,rabbit@mq3]}]},\r\n   	{running_nodes,[rabbit@mq1,rabbit@mq2,rabbit@mq3]},\r\n   	{cluster_name,<<\"rabbit@mq1\">>},\r\n   	{partitions,[]},\r\n   	{alarms,[{rabbit@mq1,[]},{rabbit@mq2,[]},{rabbit@mq3,[]}]}]\r\n   \r\n   # 8.登录管理界面,展示如下状态:\r\n   ```\r\n\r\n   ![](https://cdn.jsdelivr.net/gh/zhangliyuangit/img/image-20200320095613586.png)\r\n\r\n   ```markdown\r\n   # 9.测试集群在node1上,创建队列\r\n   ```\r\n\r\n   ![](https://cdn.jsdelivr.net/gh/zhangliyuangit/img/image-20200320095743935.png)\r\n\r\n   ```markdown\r\n   # 10.查看node2和node3节点:\r\n   ```\r\n\r\n   ![](https://cdn.jsdelivr.net/gh/zhangliyuangit/img/image-20200320095827688.png)\r\n\r\n   ![](https://cdn.jsdelivr.net/gh/zhangliyuangit/img/image-20200320095843370.png)\r\n\r\n   ```markdown\r\n   # 11.关闭node1节点,执行如下命令,查看node2和node3:\r\n   	rabbitmqctl stop_app\r\n   ```\r\n\r\n   ![](https://cdn.jsdelivr.net/gh/zhangliyuangit/img/image-20200320100000347.png)\r\n\r\n   ![](https://cdn.jsdelivr.net/gh/zhangliyuangit/img/image-20200320100010968.png)\r\n\r\n   ---\r\n\r\n#### 7.1.2 镜像集群\r\n\r\n> This guide covers mirroring (queue contents replication) of classic queues  --摘自官网\r\n>\r\n> By default, contents of a queue within a RabbitMQ cluster are located on a single node (the node on which the queue was declared). This is in contrast to exchanges and bindings, which can always be considered to be on all nodes. Queues can optionally be made *mirrored* across multiple nodes. --摘自官网\r\n\r\n`镜像队列机制就是将队列在三个节点之间设置主从关系，消息会在三个节点之间进行自动同步，且如果其中一个节点不可用，并不会导致消息丢失或服务不可用的情况，提升MQ集群的整体高可用性。`\r\n\r\n\r\n\r\n1. ##### 集群架构图\r\n\r\n   ![](https://cdn.jsdelivr.net/gh/zhangliyuangit/img/image-20200320113423235.png)\r\n\r\n   \r\n\r\n2. ##### 配置集群架构\r\n\r\n   ```markdown\r\n   # 0.策略说明\r\n   	rabbitmqctl set_policy [-p <vhost>] [--priority <priority>] [--apply-to <apply-to>] <name> <pattern>  <definition>\r\n   	-p Vhost： 可选参数，针对指定vhost下的queue进行设置\r\n   	Name:     policy的名称\r\n   	Pattern: queue的匹配模式(正则表达式)\r\n   	Definition：镜像定义，包括三个部分ha-mode, ha-params, ha-sync-mode\r\n              		ha-mode:指明镜像队列的模式，有效值为 all/exactly/nodes\r\n                           all：表示在集群中所有的节点上进行镜像\r\n                           exactly：表示在指定个数的节点上进行镜像，节点的个数由ha-params指定\r\n                           nodes：表示在指定的节点上进行镜像，节点名称通过ha-params指定\r\n               	 ha-params：ha-mode模式需要用到的参数\r\n                   ha-sync-mode：进行队列中消息的同步方式，有效值为automatic和manual\r\n                   priority：可选参数，policy的优先级\r\n                   \r\n                    \r\n   # 1.查看当前策略\r\n   	rabbitmqctl list_policies\r\n   \r\n   # 2.添加策略\r\n   	rabbitmqctl set_policy ha-all \'^hello\' \'{\"ha-mode\":\"all\",\"ha-sync-mode\":\"automatic\"}\' \r\n   	说明:策略正则表达式为 “^” 表示所有匹配所有队列名称  ^hello:匹配hello开头队列\r\n   \r\n   # 3.删除策略\r\n   	rabbitmqctl clear_policy ha-all\r\n   \r\n   # 4.测试集群\r\n   ```\r\n\r\n   ----\r\n\r\n   ', '2021-03-07 13:48:43', 'https://cdn.jsdelivr.net/gh/zhangliyuangit/img/20210315211330.png', 1, 'RabbitMQ是基于Erlang语言的高性能MQ产品');
INSERT INTO `s_article` VALUES (2, 'Docker笔记', '# docker\r\n\r\n### 虚拟机配置网络\r\n\r\n\r\n\r\n可以使用dhclient工具为虚拟机分配一个可用的ip\r\n\r\n```shell\r\n# 分配ip地址\r\ndhclient\r\n\r\n# 修改网络配置\r\nvi /etc/sysconfig/network-scripts/ifcfg-ens33\r\nBOOTPROTO=\"static\"\r\nONBOOT=\"yes\"\r\n\r\n# 添加如下配置\r\nIPADDR=192.168.31.17 #注意这是分配的IP\r\nGATEWAY=192.168.31.1\r\nDNS1=119.29.29.29\r\n\r\n```\r\n\r\n\r\n\r\n一.修改网络配置:\r\n\r\n1. `vi /etc/sysconfig/network-scripts/ifcfg-ens33`\r\n2. 输入i进入编辑模式，将最后一行的ONBOOT=no改为ONBOOT=yes\r\n3. 按Esc键，输入“：wq!”,保存并退出\r\n4. 然后重启网络，输入`service network restart`\r\n5. 输入ip addr查看ip\r\n\r\n\r\n\r\n### Docker的历史\r\n\r\n有意思的是，Docker 公司起初是一家名为 dotCloud 的平台即服务（Platform-as-a-Service, PaaS）提供商。\r\n\r\n底层技术上，dotCloud 平台利用了 Linux 容器技术。为了方便创建和管理这些容器，dotCloud 开发了一套内部工具，之后被命名为“Docker”。Docker就是这样诞生的！\r\n\r\n2013年，dotCloud 的 PaaS 业务并不景气，公司需要寻求新的突破。于是他们聘请了 Ben Golub 作为新的 CEO，将公司重命名为“Docker”，放弃dotCloud PaaS 平台，怀揣着“将 Docker 和容器技术推向全世界”的使命，开启了一段新的征程。\r\n\r\n如今 Docker 公司被普遍认为是一家创新型科技公司，据说其市场价值约为 10 亿美元。Docker 公司已经通过多轮融资，吸纳了来自硅谷的几家风投公司的累计超过 2.4 亿美元的投资。\r\n\r\n几乎所有的融资都发生在公司更名为“Docker”之后。\r\n\r\n> 提示：“Docker”一词来自英国口语，意为码头工人（Dock Worker），即从船上装卸货物的人。\r\n\r\n\r\n\r\n\r\n\r\n### Docker能干嘛\r\n\r\n> 之前的虚拟机技术\r\n\r\n![](https://cdn.jsdelivr.net/gh/zhangliyuangit/img/asdasdnsvdn.png)\r\n\r\n虚拟机缺点\r\n\r\n- 资源占用多\r\n- 冗余步骤多\r\n- 启动慢\r\n\r\n\r\n\r\n\r\n\r\n> 容器化技术\r\n\r\n容器化技术并不是一个完整的技术\r\n\r\n![](https://cdn.jsdelivr.net/gh/zhangliyuangit/img/docker1.png)\r\n\r\n一个容器包含了运行环境和应用，每个容器时互相隔离的，容器直接运行在操作系统之上，从分利用操作系统的资源。\r\n\r\n\r\n\r\n\r\n\r\nDocker 是一个开源的应用容器引擎，基于Go语言并遵从 Apache2.0 协议开源。\r\n\r\nDocker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。\r\n\r\n容器是完全使用沙箱机制，相互之间不会有任何接口（类似 iPhone 的 app）,更重要的是容器性能开销极低。\r\n\r\n\r\n\r\n**比较Docker和虚拟机不同：**\r\n\r\n- 传统虚拟机，虚拟出一个硬件，运行一个完整的操作系统，在这个系统上安装和操作软件。\r\n- 容器内的应用直接运行在宿主机的内容，容器是没有内核的，也没有虚拟我们的硬件，所以是非常轻便的。\r\n- 没有容器间是相互隔离的，每个容器都有属于自己的文件系统，互不影响。 \r\n\r\n\r\n\r\n> DevOps(开发、运维)\r\n\r\n**更快速的交付和部署。**\r\n\r\n**更便捷的升级和扩缩容**。\r\n\r\n**更简单的系统运维。**\r\n\r\n**更高效的计算机资源利用**(Docker是内核级别的虚拟化)\r\n\r\n\r\n\r\n\r\n\r\n### Docker的基本组成\r\n\r\n![](https://cdn.jsdelivr.net/gh/zhangliyuangit/img/20201220205244.png)\r\n\r\n#### 镜像(image)\r\n\r\n镜像就是一个只读的模板，镜像可以用来创建Docker容器，一个镜像可以创建很多容器\r\n\r\n#### 容器(container)\r\n\r\nDocker利用容器独立运行的一个或一组应用。容器是用镜像创建的运行实例。\r\n\r\n它可以被启用，开始，停止，删除。每个容器都是相互隔离的，保证安全的平台。\r\n\r\n**可以把容器看作是一个简易版的Linux环境**(包括root用户权限，进程空间，用户空间和网络空间等)和运行在其中的应用程序。\r\n\r\n容器的定义和镜像几乎一摸一样，也是一堆层的统一视角，唯一区别在于容器的最上面那一层是可读可写的\r\n\r\n#### 仓库(repository)\r\n\r\n仓库是集中存放镜像文件的场所。\r\n\r\n仓库和仓库注册服务器(Registry)是有区别的，仓库注册服务器上往往存放着多个仓库，每个仓库中又包含了多个镜像，每个镜像有不同的标签\r\n\r\n仓库分为公开仓库(public)和私有仓库(private)两种形式\r\n\r\n最大的开放仓库是Docker Hub： https://hub.docker.com/ 存放了数量庞大的镜像供用户下载。\r\n\r\n国内的公开仓库包括阿里云，网易云等\r\n\r\n\r\n\r\n\r\n\r\n### 安装Docker\r\n\r\n查看系统内核\r\n\r\n```shell\r\n[root@MiWiFi-R4A-srv /]# uname -r\r\n3.10.0-1062.el7.x86_64\r\n```\r\n\r\n查看系统版本\r\n\r\n```shell\r\n[root@MiWiFi-R4A-srv /]# cat /etc/os-release \r\nNAME=\"CentOS Linux\"\r\nVERSION=\"7 (Core)\"\r\nID=\"centos\"\r\nID_LIKE=\"rhel fedora\"\r\nVERSION_ID=\"7\"\r\nPRETTY_NAME=\"CentOS Linux 7 (Core)\"\r\nANSI_COLOR=\"0;31\"\r\nCPE_NAME=\"cpe:/o:centos:centos:7\"\r\nHOME_URL=\"https://www.centos.org/\"\r\nBUG_REPORT_URL=\"https://bugs.centos.org/\"\r\n\r\nCENTOS_MANTISBT_PROJECT=\"CentOS-7\"\r\nCENTOS_MANTISBT_PROJECT_VERSION=\"7\"\r\nREDHAT_SUPPORT_PRODUCT=\"centos\"\r\nREDHAT_SUPPORT_PRODUCT_VERSION=\"7\"\r\n```\r\n\r\n卸载旧的版本\r\n\r\n```shell\r\n# 卸载旧版本\r\n$ sudo yum remove docker \\\r\n                  docker-client \\\r\n                  docker-client-latest \\\r\n                  docker-common \\\r\n                  docker-latest \\\r\n                  docker-latest-logrotate \\\r\n                  docker-logrotate \\\r\n                  docker-engine\r\n                  \r\n                  \r\n# 需要的安装包\r\nsudo yum install -y yum-utils\r\n\r\n# 设置镜像的仓库\r\nsudo yum-config-manager \\\r\n    --add-repo \\\r\n    http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo\r\n\r\n# 更新yum软件包索引\r\nyum makecache fast\r\n\r\n# 安装docker相关 docker-ce社区版  ee版企业版\r\nsudo yum install docker-ce docker-ce-cli containerd.io\r\n\r\n# 启动docker\r\nsudo systemctl start docker\r\n\r\n# 使用docker -version查看是否安装成功\r\ndocker -version\r\n\r\n# hello world程序\r\ndocker run hello-world\r\n\r\n# 查看镜像\r\n[root@MiWiFi-R4A-srv ~]# docker images\r\nREPOSITORY    TAG       IMAGE ID       CREATED         SIZE\r\ntomcat        latest    6d15a1d68603   7 days ago      649MB\r\nmysql         8.0.22    ab2f358b8612   8 days ago      545MB\r\nmysql         latest    ab2f358b8612   8 days ago      545MB\r\nredis         latest    ef47f3b6dc11   8 days ago      104MB\r\ncentos        centos7   8652b9f0cb4c   5 weeks ago     204MB\r\nhello-world   latest    bf756fb1ae65   11 months ago   13.3kB\r\n\r\n\r\n```\r\n\r\n\r\n\r\n**卸载Docker**\r\n\r\n```shell\r\n# 卸载依赖\r\n$ sudo yum remove docker-ce docker-ce-cli containerd.io\r\n\r\n# 删除资源\r\n$ sudo rm -rf /var/lib/docker\r\n```\r\n\r\n\r\n\r\n### 阿里云镜像加速\r\n\r\n![](https://cdn.jsdelivr.net/gh/zhangliyuangit/img/20201220215957.png)\r\n\r\n\r\n\r\n\r\n\r\n![](https://cdn.jsdelivr.net/gh/zhangliyuangit/img/20201220220050.png)\r\n\r\n```shell\r\nsudo mkdir -p /etc/docker\r\n\r\nsudo tee /etc/docker/daemon.json <<-\'EOF\'\r\n{\r\n  \"registry-mirrors\": [\"https://n1p195zp.mirror.aliyuncs.com\"]\r\n}\r\nEOF\r\n\r\nsudo systemctl daemon-reload\r\n\r\nsudo systemctl restart docker\r\n```\r\n\r\n\r\n\r\n\r\n\r\n### 底层原理\r\n\r\n\r\n\r\n**Docker是怎么工作的？**\r\n\r\nDocker是一个Client-Server结构的系统，Docker守护进程运行在主机上， 然后通过Socket连接从客户端访问，守护进程从客户端接受命令并管理运行在主机上的容器。\r\n\r\nDockerServer接收到Docker-Client的指令，就会执行这个命令。\r\n\r\n**为什么Docker比VM快？**\r\n\r\n1. Docker有着虚拟机更少的抽象层，由于Docker不需要Hypervisor实现硬件资源虚拟化，运行在Docker容器上的程序直接使用的都是实际物理机的硬件资源，因此在CPU、内存利用率上Docker将会有明显优势。\r\n2. Docker利用的是宿主机的内核，而不需要GuestOS，因此，当新建一个容器时Docker不需要和虚拟机一样重新加载一个操作系统，避免了引导、加载操作系统内核这个比较费时费资源的过程，当新建一个虚拟机时，虚拟机软件需要加载GuestOS，这个新建过程是分钟级别的，而Docker由于直接利用宿主机的操作系统则省略了这个过程，因此新建一个Docker只需几秒钟。\r\n\r\n|            | Docker容器              | 虚拟机（VM）                |\r\n| ---------- | ----------------------- | --------------------------- |\r\n| 操作系统   | 与宿主机共享OS          | 宿主机OS上运行宿主机OS      |\r\n| 存储大小   | 镜像小，便于存储与传输  | 镜像庞大（vmdk等）          |\r\n| 运行性能   | 几乎无额外性能损失      | 操作系统额外的cpu、内存消耗 |\r\n| 移植性     | 轻便、灵活、适用于Linux | 笨重、与虚拟化技术耦合度高  |\r\n| 硬件亲和性 | 面向软件开发者          | 面向硬件运维者              |\r\n\r\n\r\n\r\n### Docker的常用命令\r\n\r\n#### 帮助命令\r\n\r\n```shell\r\ndocker --version 	# 显示Docker的版本信息\r\ndocker info 	# 显示Docker的系统信息，包括镜像和容器的数量\r\ndocker --help	# 帮助命令\r\n```\r\n\r\n\r\n\r\n#### 镜像命令\r\n\r\n```shell\r\ndocker images	# 查看本地所有镜像\r\ndocker images -a	# 列出本地所有的镜像（含中间映像层）\r\ndocker images -q	# 只显示id\r\n```\r\n\r\n```shell\r\ndocker search mysql		# 搜索镜像\r\ndocker search mysql --filter=STARS=3000		# 过滤只搜索3000satr以上的\r\n```\r\n\r\n```shell\r\ndocker pull mysql	# 如果不写tag，默认latest最新版\r\ndocker pull mysql:5.7 	# 指定版本下载\r\n```\r\n\r\n```shell\r\ndocker rmi 697daaecf703		# Docker删除镜像\r\n```\r\n\r\n\r\n\r\n#### 容器命令\r\n\r\n有镜像才能创建容器，下载一个centos镜像来学习。\r\n\r\n```shell\r\ndocker pull centos\r\n```\r\n\r\n新建容器并启动\r\n\r\n```shell\r\ndocker run [可选参数] image\r\n\r\n# 参数说明\r\n--name=\"NAME\"	容器名字，用来区别容器\r\n-d				后台方式运行\r\n-it				使用交互方式运行，进入容器查看内容\r\n-p				 -p 8080:8080\r\n	-p 主机端口:容器端口(常用)\r\n	-p 容器端口\r\n	容器端口\r\n-P				随机指定端口\r\n\r\n\r\n# 测试\r\ndocker run -it centos /bin/bash\r\n\r\n# 从容器退回主机\r\nexit\r\n```\r\n\r\n\r\n\r\n列出所有正在运行的容器\r\n\r\n```shell\r\n[root@MiWiFi-R4A-srv /]# docker ps\r\nCONTAINER ID   IMAGE     COMMAND       CREATED         STATUS         PORTS     NAMES\r\n581a17d041b4   centos    \"/bin/bash\"   3 minutes ago   Up 3 minutes             nice_roentgen\r\n\r\n\r\ndocker ps -a    # 列出所有容器\r\n\r\ndocker ps -a -n=1 	# 显示最近创建的容器\r\n\r\ndocker ps -aq  # 显示当前容器的编号\r\n```\r\n\r\n退出容器\r\n\r\n```shell\r\nexit  # 直接容器停止并退出\r\nCtrl + P + Q   # 容器不停止退出\r\n```\r\n\r\n删除容器\r\n\r\n```shell\r\ndocker rm 容器id		# 删除指定的容器，不能删除正在运行的容器\r\ndocker rm -f $(docker ps -ap)		# 删除所有的容器\r\n```\r\n\r\n启动和停止容器操作\r\n\r\n```shell\r\ndocker start容器id  # 启动容器\r\ndocker restart 容器id	 # 重启容器\r\ndocker stop 容器id	# 停止容器\r\ndocker kill 容器id	#强制停止当前容器\r\n```\r\n\r\n#### 常用其他命令\r\n\r\n后台启动容器\r\n\r\n```shell\r\ndocker run -d centos\r\n# docker ps发现centos停止了\r\n# 常见的坑，dokcer容器使用后台运行，就必须要有一个前台进程，docker发现没有应用，就会自动停止\r\n```\r\n\r\n查看日志\r\n\r\n```shell\r\ndocker logs -f -t --tail 容器id\r\n```\r\n\r\n查看容器中进程信息\r\n\r\n```shell\r\n[root@MiWiFi-R4A-srv ~]# docker top 847858ee8a4a\r\nUID                 PID                 PPID                C                   STIME               TTY                 TIME                CMD\r\nroot                5967                5947                0                   22:28               ?                   00:00:00            /bin/bash\r\n\r\n```\r\n\r\n查看镜像的元数据\r\n\r\n```shell\r\ndocker inspect 847858ee8a4a\r\n```\r\n\r\n\r\n\r\n#### 进入当前正在运行的容器\r\n\r\n```shell\r\n# 方式一  开启一个新的终端\r\ndocker exec -it 847858ee8a4a /bin/bash\r\n\r\n# 方式二  执行正在运行的终端\r\ndocker attach 847858ee8a4a #正在执行当前的代码\r\n```\r\n\r\n\r\n\r\n#### 从容器内部拷贝文件到主机上\r\n\r\n```shell\r\ndocker cp 容器id：容器内路径 目的主机路径\r\n\r\n# 将dockers内部/home下的zhang.java拷贝到主机的home\r\ndocker cp dc6084befe30:/home/zhang.java /home\r\n```\r\n\r\n\r\n\r\n![](https://cdn.jsdelivr.net/gh/zhangliyuangit/img/20201223212032.png)\r\n\r\n\r\n\r\n\r\n\r\n### 练习\r\n\r\n> Docker安装nginx\r\n\r\n```shell\r\n# 搜索镜像\r\ndocker search nginx\r\n# 下载镜像\r\ndocker pull nginx\r\n# 运行镜像 -d后台运行  --name给容器命名  -p宿主机端口\r\ndocker run -d --name nginx01 -p 3344:80 nginx\r\n```\r\n\r\n\r\n\r\n> Docker安装tomcat\r\n\r\n```shell\r\n# 官方的使用(-rm 用完及删除，用于测试)\r\ndocker run --rm tomcat:9.0\r\n```\r\n\r\n\r\n\r\n\r\n\r\n### 可视化\r\n\r\n- portainer\r\n\r\n  \r\n\r\n  docker图形化管理工具\r\n\r\n安装\r\n\r\n```shell\r\ndocker run -d -p 8088:9000 \\\r\n--restart=always -v /var/run/docker.sock:/var/run/docker.sock --privileged=true portainer/portainer\r\n```\r\n\r\n访问测试\r\n\r\n![](https://cdn.jsdelivr.net/gh/zhangliyuangit/img/docker12262.png)\r\n\r\n- Rancher(CI/CD)\r\n\r\n\r\n\r\n\r\n\r\n### Docker镜像\r\n\r\n#### 镜像是什么\r\n\r\n镜像是一个轻量级、可执行的的独立软件包，用来打包软件运行环境和基于运行环境开发的软件，它包含运行某个软件所需要的内容，包括代码，运行时库，环境变量和配置文件。\r\n\r\n\r\n\r\n**如何得到镜像呢？**\r\n\r\n- 远程仓库下载\r\n- 拷贝\r\n- 自己制作一个镜像\r\n\r\n\r\n\r\n#### Docker镜像加载原理\r\n\r\n> UnionFS(联合文件系统)\r\n\r\nUnion文件系统是一种分层、轻量级并且高性能的文件系统，它支持对文件系统的修改作为一次提交来一层层的叠加，同时可以将不同目录挂载到同一个虚拟文件系统下。Union文件系统时Docker镜像的基础。镜像可以通过分层来进行继承，基于基础镜像(没有父镜像)，可以制作各种具体的镜像。\r\n\r\n特性：一次同时加载多个文件系统，但从外面看起来，只能看到一个文件系统，联合加载会把各层文件系统叠加起来，这样最终的文件系统会包含所有底层的文件和目录。\r\n\r\n\r\n\r\n> Docker镜像的加载原理\r\n\r\ndocker 的镜像实际上由一层一层的文件系统组成，这种层级的文件系统UnionFS。\r\n\r\n**bootfs**(boot file system) 主要包含bootloader和kernel，bootloader 主要是引导加载kernel，Linux刚启动时会加载bootfs文件系统，在Docker镜像的最底层是bootfs。这一层与我们典型的Linux/Unix系统是一样的，包含boot加载器和内核。当boot加载完成之后整个内核就存在内存中了，此时内存的使用权已由bootfs转交给内核，此时系统也会卸载bootfs。\r\n\r\n**roorfs** （root file system），在bootfs之上。包含的就是典型Linux系统中的 /dev ，/proc，/bin ，/etx 等标准的目录和文件。rootfs就是各种不同的操作系统发行版。比如Ubuntu，Centos等等。\r\n\r\n对于一个精简的OS，rootfs可以很小，只需要包括最基本的命令、工具和程序库就可以了，因为底层直接用Host（宿主机）的kernel，自己只需要提供rootfs就行了，由此可见对于不同的Linux发行版，bootfs基本是一致的，rootfs会有差别，因此不同的发行版可以公用bootfs。\r\n\r\n\r\n\r\n> **特点**\r\n\r\nDocker镜像都是只读的，当容器启动时，一个新的可写层被加到镜像的顶部。这一层就是我们通常说的容器层，容器之下都叫镜像层。\r\n\r\n![](https://cdn.jsdelivr.net/gh/zhangliyuangit/img/asdasdaew9097878.png)\r\n\r\n![](https://cdn.jsdelivr.net/gh/zhangliyuangit/img/docker12261.png)\r\n\r\n\r\n\r\n\r\n\r\n### Commit镜像\r\n\r\n```shell\r\ndocker commit  # 提交容器成为一个新的版本\r\n\r\ndocker commit -m=\"提交的描述信息\" -a=\"作者\" 容器id 目标镜像名:[tag]\r\n```\r\n\r\n\r\n\r\n**实战测试**\r\n\r\n```shell\r\n# 启动一个默认的tomcat\r\ndocker run -it -p 9999:9999 tomcat\r\n\r\n# 发现这个tomcat，webapps下面时没有文件的\r\nroot@24cc7cd482ff:/usr/local/tomcat# cd webapps\r\nroot@24cc7cd482ff:/usr/local/tomcat/webapps# ls\r\n\r\n# 自己拷贝进去基本的文件\r\nroot@24cc7cd482ff:/usr/local/tomcat# cp -r webapps.dist/* webapps\r\n\r\n# 生成一个新镜像\r\ndocker commit -a=\"zhang\" -m=\"add webapps app\" 24cc7cd482ff tomcat02:1.0\r\n\r\n```\r\n\r\n这就是我们修改过的镜像\r\n\r\n![](https://cdn.jsdelivr.net/gh/zhangliyuangit/img/docker12264.png)\r\n\r\n\r\n\r\n### 安装MySQL\r\n\r\nmysql数据的持久化问题\r\n\r\n```shell\r\n[root@izbp13r5pmefkwfqgkx4i2z ~]# docker run -d -p 3310:3306 -v /home/mysql/conf:/etc/mysql/conf.d -v /home/mysql/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=root --name mysql01 mysql\r\ne1911d0e9045f63df828e4639196ce32e1bf631e21df3c7fb789c487055d572b\r\n\r\n# 启动mysql\r\n-d 后台运行\r\n-p 端口映射\r\n-v 卷挂载\r\n-e 环境配置  密码\r\n--name 容器名称\r\n```\r\n\r\n测试连接\r\n\r\n![](https://cdn.jsdelivr.net/gh/zhangliyuangit/img/docker12265.png)\r\n\r\n进入host的home目录，发现mysql目录，进入data目录可以看到数据。\r\n\r\n![](https://cdn.jsdelivr.net/gh/zhangliyuangit/img/docker12266.png)\r\n\r\n我们利用本地navicat新建一个数据库，再次查看data目录下文件\r\n\r\n![](https://cdn.jsdelivr.net/gh/zhangliyuangit/img/docker12267.png)\r\n\r\n发现多了test文件，说明映射的路径是ok的。\r\n\r\n假设我们删除容器\r\n\r\n![](https://cdn.jsdelivr.net/gh/zhangliyuangit/img/docker12268.png)\r\n\r\n发现数据并没消失\r\n\r\n![](https://cdn.jsdelivr.net/gh/zhangliyuangit/img/docker12269.png)\r\n\r\n\r\n\r\n### Dockerfile\r\n\r\ndockerfile就是用来构建docker镜像的构建文件(命令脚本,通过这个脚本可以生成镜像)\r\n\r\n```shell\r\n# 创建一个dockerfile文件\r\nFROM centos\r\nVOLUME [\"volume01\",\"volume02\"]\r\nCMD echo \"------end--------\"\r\nCMD /bin/bash\r\n\r\n```\r\n\r\n```shell\r\ndocker build -f /home/docker-test-voume/dockerfile01 -t zhangdemo/centos:1.o .\r\n```\r\n\r\n![](https://cdn.jsdelivr.net/gh/zhangliyuangit/img/docker122610.png)\r\n\r\n\r\n\r\n启动自己的镜像\r\n\r\n![](https://cdn.jsdelivr.net/gh/zhangliyuangit/img/docker122611.png)\r\n\r\n\r\n\r\n\r\n\r\n构建步骤\r\n\r\n1. 编写一个dokerfile文件\r\n2. docker build构建一个镜像\r\n3. docker run 运行镜像\r\n4. docker push 发布镜像 \r\n\r\n#### 基础知识\r\n\r\n- 每个关键字都是大写\r\n- 执行从上到下的顺序\r\n- `#` 表示注释\r\n- 每一个指令都会创建提交一个新的镜像层，并提交\r\n\r\n![](https://cdn.jsdelivr.net/gh/zhangliyuangit/img/20201226181209.png)\r\n\r\ndockerfile是面向开发。Docker逐渐成为了企业交付的标准。\r\n\r\n\r\n\r\n#### DockerFile的指令\r\n\r\n```shell\r\nFROM   		# 基础镜像，一切从这里开始构建\r\nMAINTAINER	# 镜像是谁写的，姓名+邮箱\r\nRUN			# 镜像构建的时候需要运行的命令\r\nADD			# 步骤，tomcat镜像，这个tomcat的压缩包！添加内容\r\nWORKDIR		# 镜像的工作目录\r\nVOLUME		# 挂载的目录位置\r\nEXPOST		# 暴露端口\r\nCMD			# 指定容器启动时要输出的命令，只有最后一个会生效，可被替代\r\nENTRYPOINT	# 指定容器启动时要输出的命令，可以追加命令\r\nONBUILD		# 当构建一个被继承DockerFile这个时候就会运行ONBUILD指令，触发指令。\r\nCOPY		# 类似ADD命令，将文件拷贝到镜像中\r\nENV			# 构建的时候设置环境变量\r\n```\r\n\r\n\r\n\r\n![](https://cdn.jsdelivr.net/gh/zhangliyuangit/img/20201226181721.png)\r\n\r\n\r\n\r\n\r\n\r\n#### 构建自己的Centos\r\n\r\n\r\n\r\n**1.编写dockerfile的配置文件**\r\n\r\n```shell\r\n#基于Centos\r\nFROM centos\r\n\r\n#告诉别人我是谁\r\nMAINTAINER zhang<495726603@qq.com>\r\n\r\n#环境变量\r\nENV MYPATH /usr/local\r\n\r\n#工作目录\r\nWORKDIR $MYPATH\r\n\r\n#安装一个vim\r\nRUN yum -y install vim\r\n\r\nRUN yum -y install net-tools\r\n\r\nEXPOSE 80\r\n\r\nCMD echo $MYPATH\r\nCMD echo \"-----end-------\"\r\n\r\nCMD /bin/bash\r\n```\r\n\r\n**2.通过文件构建镜像**\r\n\r\n```shell\r\ndocker build -f mydockerfile -t mycentos:v1 .\r\n\r\n# -f 代表dockerfile的文件路径\r\n# -t 镜像名和版本号\r\n```\r\n\r\n![](https://cdn.jsdelivr.net/gh/zhangliyuangit/img/docker122612.png)\r\n\r\n**3.测试运行**\r\n\r\n可以看到运行的工作目录为我们在dockerfile中配置的工作目录，\r\n\r\n并且`ifconfig`命令可用了.\r\n\r\n![](https://cdn.jsdelivr.net/gh/zhangliyuangit/img/docker122613.png)\r\n\r\n**4.可以通过`docker history 镜像id`列出本地镜像的变更地址**\r\n\r\n![](https://cdn.jsdelivr.net/gh/zhangliyuangit/img/docker122614.png)\r\n\r\n\r\n\r\n\r\n\r\n> CMD和ENTRYPOINT的区别\r\n\r\n测试cmd\r\n\r\n```shell\r\n# 编写dockerfile文件\r\nvim dockerfile-cmd-test\r\n\r\nFROM centos\r\nCMD [\"ls\",\"-a\"]\r\n\r\n#构建镜像\r\ndocker build -f dockerfile-cmd-test -t cmdtest .\r\n\r\n#run运行，发现我们的ls -a命令生效\r\n[root@izbp13r5pmefkwfqgkx4i2z dockerfile]# docker run bef2698bd130\r\n.\r\n..\r\n.dockerenv\r\nbin\r\ndev\r\netc\r\nhome\r\nlib\r\nlib64\r\nlost+found\r\nmedia\r\n\r\n#想追加一个命令 -l ls -al\r\n[root@izbp13r5pmefkwfqgkx4i2z ~]# docker run bef2698bd130 -l\r\ndocker: Error response from daemon: OCI runtime create failed: container_linux.go:370: starting container process caused: exec: \"-l\": executable file not found in $PATH: unknown.\r\n\r\n#cmd的情况下 -l替换了CMD[\"ls\",\"-a\"]命令 ，不是命令所以报错\r\n\r\n```\r\n\r\n测试entryporint(我们追加的命令，是直接在我们的entrypoint命令后面的)\r\n\r\n```shell\r\n[root@izbp13r5pmefkwfqgkx4i2z ~]# vim dockerfile-cmd-entrypoint\r\n[root@izbp13r5pmefkwfqgkx4i2z ~]# docker build -f dockerfile-cmd-entrypoint -t entorypoint-test .\r\nSending build context to Docker daemon    726kB\r\nStep 1/2 : FROM centos\r\n ---> 300e315adb2f\r\nStep 2/2 : ENTRYPOINT [\"ls\",\"-a\"]\r\n ---> Running in 51ffcc67a242\r\nRemoving intermediate container 51ffcc67a242\r\n ---> 4645e2e60db1\r\nSuccessfully built 4645e2e60db1\r\nSuccessfully tagged entorypoint-test:latest\r\n[root@izbp13r5pmefkwfqgkx4i2z ~]# docker images\r\nREPOSITORY            TAG       IMAGE ID       CREATED          SIZE\r\nentorypoint-test      latest    4645e2e60db1   15 seconds ago   209MB\r\ncmdtest               latest    bef2698bd130   14 minutes ago   209MB\r\nmycentos              v1        ee0d621d29ee   2 hours ago      282MB\r\nzhangdemo/centos      1.o       8bb60281dfef   4 hours ago      209MB\r\nmysql                 latest    a347a5928046   4 days ago       545MB\r\ntomcat                latest    feba8d001e3f   8 days ago       649MB\r\nredis                 latest    ef47f3b6dc11   2 weeks ago      104MB\r\ncentos                latest    300e315adb2f   2 weeks ago      209MB\r\nportainer/portainer   latest    62771b0b9b09   5 months ago     79.1MB\r\nhello-world           latest    bf756fb1ae65   11 months ago    13.3kB\r\n[root@izbp13r5pmefkwfqgkx4i2z ~]# docker run 4645e2e60db1\r\n.\r\n..\r\n.dockerenv\r\nbin\r\ndev\r\netc\r\nhome\r\nlib\r\nlib64\r\nlost+found\r\nmedia\r\nmnt\r\nopt\r\nproc\r\nroot\r\nrun\r\nsbin\r\nsrv\r\nsys\r\ntmp\r\nusr\r\nvar\r\n[root@izbp13r5pmefkwfqgkx4i2z ~]# docker run 4645e2e60db1 -l\r\ntotal 56\r\ndrwxr-xr-x  1 root root 4096 Dec 26 13:15 .\r\ndrwxr-xr-x  1 root root 4096 Dec 26 13:15 ..\r\n-rwxr-xr-x  1 root root    0 Dec 26 13:15 .dockerenv\r\nlrwxrwxrwx  1 root root    7 Nov  3 15:22 bin -> usr/bin\r\ndrwxr-xr-x  5 root root  340 Dec 26 13:15 dev\r\ndrwxr-xr-x  1 root root 4096 Dec 26 13:15 etc\r\ndrwxr-xr-x  2 root root 4096 Nov  3 15:22 home\r\nlrwxrwxrwx  1 root root    7 Nov  3 15:22 lib -> usr/lib\r\nlrwxrwxrwx  1 root root    9 Nov  3 15:22 lib64 -> usr/lib64\r\ndrwx------  2 root root 4096 Dec  4 17:37 lost+found\r\ndrwxr-xr-x  2 root root 4096 Nov  3 15:22 media\r\ndrwxr-xr-x  2 root root 4096 Nov  3 15:22 mnt\r\ndrwxr-xr-x  2 root root 4096 Nov  3 15:22 opt\r\ndr-xr-xr-x 90 root root    0 Dec 26 13:15 proc\r\ndr-xr-x---  2 root root 4096 Dec  4 17:37 root\r\ndrwxr-xr-x 11 root root 4096 Dec  4 17:37 run\r\nlrwxrwxrwx  1 root root    8 Nov  3 15:22 sbin -> usr/sbin\r\ndrwxr-xr-x  2 root root 4096 Nov  3 15:22 srv\r\ndr-xr-xr-x 13 root root    0 Dec 26 13:15 sys\r\ndrwxrwxrwt  7 root root 4096 Dec  4 17:37 tmp\r\ndrwxr-xr-x 12 root root 4096 Dec  4 17:37 usr\r\ndrwxr-xr-x 20 root root 4096 Dec  4 17:37 var\r\n\r\n```\r\n\r\n\r\n\r\n####  实战：Tomcat镜像\r\n\r\n1.准备镜像文件，tomcat压缩包，tomcat依赖java，需要jdk\r\n\r\n![](https://cdn.jsdelivr.net/gh/zhangliyuangit/img/docker12271.png)\r\n\r\n2.编写dockekfile文件。官方命名`Dockerfile`，使用这个就不需要加-f指定文件名\r\n\r\n```shell\r\n# 基础镜像\r\nFROM centos\r\n\r\nMAINTAINER zhangliyuan<495726603@qq.com>\r\n\r\nCOPY readme.txt /tomcat/readme.txt\r\n\r\n# 用add命令会自动帮我们解压\r\nADD jdk-11.0.8_linux-x64_bin.tar.gz /usr/local/\r\n\r\nADD apache-tomcat-9.0.41.tar.gz /usr/local/\r\n\r\n\r\n# 安装vim\r\nRUN yum -y install vim\r\n\r\n# 环境变量\r\nENV MYPATH /usr/local\r\n\r\n# 工作目录\r\nWORKDIR $MYPATH\r\n\r\n# java环境变量\r\nENV JAVA_HOME /usr/loacl/jdk11.0.8\r\n\r\nENV CLASSPATH $JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar\r\n\r\n# 配置tomcat环境变量\r\nENV CATALINA_HOME /usr/local/apache-tomcat-9.0.41\r\nENV CATALINA_BASH /usr/local/apache-tomcat-9.0.41\r\n\r\nENV PATH $PATH:$JAVA_HOME/bin:$CATALINA_HOME/lib:$CATALINA_HOME/bin\r\n\r\n#暴露端口\r\nEXPOSE 8080\r\n\r\n# tomcat日志\r\nCMD /usr/local/apache-tomcat-9.0.41/bin/startup.sh && tail -F /usr/local/apache-tomcat-9.0.41/bin/logs/catalina.out\r\n```\r\n\r\n3.构建镜像\r\n\r\n```shell\r\ndocker build -t diytomcat .\r\n```\r\n\r\n\r\n\r\n\r\n\r\n### 发布自己的镜像\r\n\r\n#### DockerHub\r\n\r\n登录dockerhub\r\n\r\n```docker login -u zhangliyuandocker```\r\n\r\n增加一个tag\r\n\r\n`docker tag a6c12980154f zhangliyuan/tomcat:1.0`\r\n\r\n提交\r\n\r\n`docker push zhangliyuan/tomcat:1.0`\r\n\r\n![](https://cdn.jsdelivr.net/gh/zhangliyuangit/img/docker12272.png)\r\n\r\n\r\n\r\n\r\n\r\n#### 阿里云\r\n\r\n- 找到镜像容器服务\r\n- 创建命名空间\r\n- 创建容器镜像\r\n\r\n![](https://cdn.jsdelivr.net/gh/zhangliyuangit/img/docker12273.png)\r\n\r\n\r\n\r\n\r\n\r\n### Springboot项目打包\r\n\r\n- 在idea中新建Dockerfile文件\r\n\r\n```shell\r\nFROM java:8\r\n\r\nWORKDIR /app\r\n\r\nCOPY upload.jar .\r\n\r\nCMD [\"--server.port=8080\"]\r\n\r\n\r\nEXPOSE 8080\r\n\r\nENTRYPOINT java -jar upload.jar\r\n```\r\n\r\n- 将Dockerfile和jar包用xftp上传到服务器\r\n\r\n![](https://cdn.jsdelivr.net/gh/zhangliyuangit/img/docker12274.png)\r\n\r\n- 构建镜像\r\n\r\n`docker build -t zhangupload .`\r\n\r\n- 运行\r\n\r\n`docker run -d -P --name upload zhangupload`\r\n\r\n- 测试\r\n\r\n![](https://cdn.jsdelivr.net/gh/zhangliyuangit/img/docker12275.png)\r\n\r\n- 查看日志\r\n\r\n`sudo docker logs -f -t --tail 行数 容器名`', '2021-03-14 18:11:13', 'https://cdn.jsdelivr.net/gh/zhangliyuangit/img/20210315210927.png', 1, 'Docker 是一个开源的应用容器引擎，基于 Go 语言 并遵从 Apache2.0 协议开源。\r\n\r\nDocker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。\r\n\r\n容器是完全使用沙箱机制，相互之间不会有任何接口（类似 iPhone 的 app）,更重要的是容器性能开销极低。');
INSERT INTO `s_article` VALUES (3, 'Mybatis', '\r\n\r\n# Mybatis\r\n\r\n## 配置解析\r\n\r\n### 核心配置文件\r\n\r\n- mybatis-config.xml  \r\n- MyBatis 的配置文件包含了会深深影响 MyBatis 行为的设置和属性信息。 配置文档的顶层结构如下：\r\n  - configuration（配置）\r\n    - [properties（属性）](https://mybatis.org/mybatis-3/zh/configuration.html#properties)\r\n    - [settings（设置）](https://mybatis.org/mybatis-3/zh/configuration.html#settings)\r\n    - [typeAliases（类型别名）](https://mybatis.org/mybatis-3/zh/configuration.html#typeAliases)\r\n    - [typeHandlers（类型处理器）](https://mybatis.org/mybatis-3/zh/configuration.html#typeHandlers)\r\n    - [objectFactory（对象工厂）](https://mybatis.org/mybatis-3/zh/configuration.html#objectFactory)\r\n    - [plugins（插件）](https://mybatis.org/mybatis-3/zh/configuration.html#plugins)\r\n    - environments（环境配置）\r\n      - environment（环境变量）\r\n        - transactionManager（事务管理器）\r\n        - dataSource（数据源）\r\n    - [databaseIdProvider（数据库厂商标识）](https://mybatis.org/mybatis-3/zh/configuration.html#databaseIdProvider)\r\n    - [mappers（映射器）](https://mybatis.org/mybatis-3/zh/configuration.html#mappers)\r\n\r\n### 环境配置\r\n\r\nMyBatis可以配置成适应多种环境\r\n\r\n**不过要记住：尽管可以配置多个环境，但每个SqlSessionFactory实例智能选择一种环境。**\r\n\r\nMybatis默认的事务管理器就是JDBC，连接池POOLED\r\n\r\n### 属性(properties)\r\n\r\n我们可以通过properties属性实现引用配置文件\r\n\r\n这些属性可以在外部进行配置，并可以进行动态替换。你既可以在典型的 Java 属性文件中配置这些属性，也可以在 properties 元素的子元素中设置。\r\n\r\n编写一个配置文件:db.properties\r\n\r\n```properties\r\ndriverClassName=com.mysql.cj.jdbc.Driver\r\nurl=jdbc:mysql://localhost:3306/test?serverTimezone=UTC\r\nusername=root\r\npassword=root\r\n```\r\n\r\n在核心配置文件中引入\r\n\r\n```xml\r\n	<!--    引入外部配置文件-->\r\n    <properties resource=\"db.properties\"/>\r\n```\r\n\r\n### 类型别名\r\n\r\n类型别名可为 Java 类型设置一个缩写名字。 它仅用于 XML 配置，意在降低冗余的全限定类名书写。\r\n\r\n```xml\r\n<!--  可以给实体类起别名-->\r\n    <typeAliases>\r\n        <typeAlias type=\"cn.demomybatis.domain.Student\" alias=\"Student\"/>\r\n    </typeAliases>\r\n```\r\n\r\n也可以指定一个包名，MyBatis 会在包名下面搜索需要的 Java Bean\r\n\r\n扫描实体类的包，他的默认别名就为这个类的类名首字母小写\r\n\r\n### 设置\r\n\r\n| 设置名                   | 描述                                                         | 有效值      | 默认值 |\r\n| :----------------------- | :----------------------------------------------------------- | :---------- | :----- |\r\n| mapUnderscoreToCamelCase | 是否开启驼峰命名自动映射，即从经典数据库列名 A_COLUMN 映射到经典 Java 属性名 aColumn。 | true\\|False | false  |\r\n\r\n### 映射器\r\n\r\nMapperRegistry:注册绑定我们的Mapper文件\r\n\r\n方式一：\r\n\r\n```xml\r\n<!-- 使用相对于类路径的资源引用 -->\r\n<mappers>\r\n  <mapper resource=\"cn/demomybatis/dao/StudentDao.xml\"/>\r\n</mappers>\r\n```\r\n\r\n方式二：\r\n\r\n```xml\r\n<!-- 使用映射器接口实现类的完全限定类名 -->\r\n<mappers>\r\n  <mapper class=\"cn.demomybatis.dao.StudentDao\"/>\r\n</mappers>\r\n```\r\n\r\n方式三：\r\n\r\n```xml\r\n<!-- 将包内的映射器接口实现全部注册为映射器 -->\r\n<mappers>\r\n  <package name=\"cn.demomybatis.dao\"/>\r\n</mappers>\r\n```\r\n\r\n### 生命周期和作用域\r\n\r\n生命周期和作用域是只管重要的，因为错误的使用会导致非常严重的**并发问题**\r\n\r\n## 解决属性名和字段名不一致问题\r\n\r\n### resultMap\r\n\r\n结果集映射\r\n\r\n```xml\r\n	<!--    结果集映射-->\r\n    <resultMap id=\"StudentMap\" type=\"Student\">\r\n        <!--        column是数据库中的字段，property是实体类中的字段-->\r\n        <result column=\"u_id\" property=\"id\"></result>\r\n    </resultMap>\r\n```\r\n\r\n- resultMap元素是MyBatis中最重要最强大的元素\r\n\r\n- ResultMap的设计思想是，对于简单的语句根本不需要配置显式的结果映射，对于复杂一点的语句只需要猫叔他们的关系就行了\r\n- ResultMap最优秀的地方在于，虽然你已经对他相当了解了，但根本不需要显式的用到他们。\r\n\r\n## 日志\r\n\r\n### 日志工厂\r\n\r\n如果一个数据库操作出现了异常，我们需要排错。日志就是最好的帮手！\r\n\r\n| 设置名  | 描述                                                  | 有效值                                                       | 默认值 |\r\n| :-----: | :---------------------------------------------------- | :----------------------------------------------------------- | :----- |\r\n| logImpl | 指定 MyBatis 所用日志的具体实现，未指定时将自动查找。 | SLF4J，LOG4J，LOG4J2，JDK_LOGGING，COMMONS_LOGGING，STDOUT_LOGGING，NO_LOGGING | 未设置 |\r\n\r\n```xml\r\n<settings>\r\n        <!--        标准的日志实现-->\r\n        <setting name=\"logImpl\" value=\"STDOUT_LOGGING\"/>\r\n    </settings>\r\n```\r\n\r\n### LOG4J\r\n\r\n什么式log4j？\r\n\r\n- Log4j是[Apache](https://baike.baidu.com/item/Apache/8512995)的一个开源项目，通过使用Log4j，我们可以控制日志信息输送的目的地是[控制台](https://baike.baidu.com/item/控制台/2438626)、文件、[GUI](https://baike.baidu.com/item/GUI)组件\r\n- 我们也可以控制每一条日志的输出格式\r\n- 通过定义每一条日志信息的级别，我们能够更加细致地控制日志的生成过程。\r\n- 通过一个[配置文件](https://baike.baidu.com/item/配置文件/286550)来灵活地进行配置，而不需要修改应用的代码。\r\n\r\n\r\n\r\n1.先导入LOG4J的jar包\r\n\r\n2.log4j.properties配置文件\r\n\r\n```properties\r\n#############################################\r\n#\r\n# Log4J 配置文件\r\n#\r\n#############################################\r\n\r\n# 定义缺省的日志级别和输出对象\r\nlog4j.rootLogger=DEBUG,INFO, logfile,console\r\n\r\n# 设定控制台输出模式\r\nlog4j.appender.console=org.apache.log4j.ConsoleAppender\r\nlog4j.appender.console.layout=org.apache.log4j.PatternLayout\r\nlog4j.appender.console.layout.ConversionPattern=[%d{MM/dd HH:mm:ss}] [%-3p] %c{1}: %m%n\r\n\r\n# 针对package定义日志级别\r\nlog4j.logger.org.apache=WARN\r\nlog4j.logger.com.paic.pafademo=DEBUG\r\n\r\n# 设定日志文件的输出模式\r\nlog4j.appender.logfile=org.apache.log4j.DailyRollingFileAppender\r\nlog4j.appender.logfile.DatePattern=yyyyMMdd\r\n# ${pafa.log.home}通过参数-D指定，比如启动WebLogic时加入参数-Dpafa.log.home=c:/\r\nlog4j.appender.logfile.File=${log.home}/appdemo/pafa.log\r\nlog4j.appender.logfile.layout=org.apache.log4j.PatternLayout\r\nlog4j.appender.logfile.layout.ConversionPattern=%d{MM/dd HH:mm:ss} [%-3p] %c{1}: %m%n\r\n\r\n# 如果要查看iBATIS的SQL日志信息，确保有下面配置\r\nlog4j.logger.com.ibatis=DEBUG\r\nlog4j.logger.java.sql.Connection=DEBUG\r\nlog4j.logger.java.sql.Statement=DEBUG\r\nlog4j.logger.java.sql.PreparedStatement=DEBUG\r\n```\r\n\r\n3.配置log4j为日志的实现\r\n\r\n```xml\r\n<settings>\r\n      <setting name=\"logImpl\" value=\"LOG4J\"/>\r\n </settings>\r\n```\r\n\r\n#### 简单使用\r\n\r\n1.在要使用的Log4j的类中，导入import org.apache.log4j.Logger;\r\n\r\n2.日志对象，参数为当前类的class\r\n\r\n```java\r\nstatic Logger logger = Logger.getLogger(mybatistest.class);\r\n```\r\n\r\n## 分页\r\n\r\n### 使用limit分类\r\n\r\n使用MyBatis实现分页，核心SQL\r\n\r\n1.接口\r\n\r\n```java\r\n	//分页\r\n    List<Student> getStudentByLimit(Map<String,Integer> map);\r\n```\r\n\r\n2.StudentDao.xml\r\n\r\n```xml\r\n<select id=\"getStudentByLimit\" resultType=\"Student\" parameterType=\"map\">\r\n        select * from student limit #{startIndex},#{pageSize}\r\n    </select>\r\n```\r\n\r\n3.测试\r\n\r\n```java\r\n@Test\r\n    public void getStudentByLimit(){\r\n        SqlSession sqlSession = MybatisUtils.getSqlSession();\r\n        StudentDao studentDao = sqlSession.getMapper(StudentDao.class);\r\n        Map<String,Integer> map = new HashMap();\r\n        map.put(\"startIndex\",0);\r\n        map.put(\"pageSize\",2);\r\n        List<Student> studentList = studentDao.getStudentByLimit(map);\r\n        for (Student student : studentList) {\r\n            System.out.println(student);\r\n        }\r\n        sqlSession.close();\r\n    }\r\n```\r\n\r\n### RowBounds分页\r\n\r\n\r\n\r\n## 注解开发\r\n\r\n1.注解在接口上使用\r\n\r\n```java\r\n@Select(\"select * from student\")\r\n    List<Student> getStudents();\r\n```\r\n\r\n2.需要在核心配置文件中绑定接口\r\n\r\n```xml\r\n<mappers>\r\n<!--        <mapper resource=\"cn/demomybatis/dao/StudentDao.xml\"/>-->\r\n<!--        <mapper class=\"cn.demomybatis.dao.StudentDao\"/>-->\r\n        <package name=\"cn.demomybatis.dao\"/>\r\n    </mappers>\r\n```\r\n\r\n\r\n\r\n本质：反射机制实现\r\n\r\n底层：动态代理！\r\n\r\n**MyBatis详细执行流程**\r\n\r\n<img src=\"https://cdn.jsdelivr.net/gh/zhangliyuangit/img/asdasdas.jpg\" style=\"zoom: 80%;\" />\r\n\r\n\r\n\r\n### CRUD\r\n\r\n我们可以在创建工具类的时候实现自动提交事务！\r\n\r\n```java\r\npublic static SqlSession getSqlSession(){\r\n    return sqlSessionFactory.openSession(true);\r\n}\r\n```\r\n\r\n编写接口，增加注释\r\n\r\n```java\r\n	//方法存在多个参数，所有参数前面必须加上@Param注解\r\n    @Select(\"select * from student where id = #{id}\")\r\n    Student getStudentById1(@Param(\"id\") int id);\r\n\r\n    @Insert(\"insert into student(id,name,age,phone) values(#{id},#{name},#{age},#{phone})\")\r\n    int addStudent1(Student student);\r\n\r\n\r\n    @Update(\"update student set name=#{name},age=#{age},phone=#{phone} where id = #{id}\")\r\n    int updateStudent1(Student student);\r\n```\r\n\r\n### 关于@Param注解\r\n\r\n- 基本类型的参数或者String类型，需要加上\r\n- 引用类型不需要加\r\n- 如果只有一个基本类型的话，可以忽略，但是建议加上\r\n- 我们在SQL中引用的就是我们这里的@Param()中设定的属性名！\r\n\r\n\r\n\r\n## Lombok\r\n\r\n使用步骤：\r\n\r\n1.在IDEA中安装Lombok插件\r\n\r\n2.在项目导入Lombok的jar包\r\n\r\n3.\r\n\r\n```java\r\n@Data：生成无参构造，get，set，toString，hashcode，equals\r\n@AllArgsConstructor   有参构造方法\r\n@NoArgsConstructor    无参构造方法\r\n```\r\n\r\n## 多对一处理\r\n\r\n按照插叙嵌套处理\r\n\r\n```xml\r\n<!--\r\n     思路：\r\n            1.查询所有的学生信息\r\n            2.根据查询出来的tid，寻找对应的老师！   子查询-->\r\n    \r\n    <select id=\"getStudent\" resultMap=\"StudentTeacher\">\r\n        select * from student\r\n    </select>\r\n\r\n    <resultMap id=\"StudentTeacher\" type=\"Student\">\r\n        <result property=\"id\" column=\"id\"/>\r\n        <result property=\"name\" column=\"name\"/>\r\n        <!--复杂的属性，我们需要单独处理 对象：association 集合：collection-->\r\n        <association property=\"teacher\" column=\"tid\" javaType=\"Teacher\" select=\"getTeacher\"/>\r\n    </resultMap>\r\n\r\n\r\n    <select id=\"getTeacher\" resultType=\"Teacher\">\r\n        select * from teacher where id = #{id}\r\n    </select>\r\n```\r\n\r\n按照结果嵌套处理\r\n\r\n```xml\r\n	<select id=\"getStudent2\" resultMap=\"StudentTeacher2\">\r\n        select s.id sid,s.name sname,t.name tname from student s,teacher t where s.tid=t.id;\r\n    </select>\r\n    <resultMap id=\"StudentTeacher2\" type=\"Student\">\r\n        <result property=\"id\" column=\"sid\"/>\r\n        <result property=\"name\" column=\"sname\"/>\r\n        <association property=\"teacher\" javaType=\"Teacher\">\r\n            <result property=\"name\" column=\"tname\"/>\r\n        </association>\r\n    </resultMap>\r\n```\r\n\r\n## 一对多处理\r\n\r\n同理\r\n\r\n### 小结\r\n\r\n1.关联 - association 【多对一】\r\n\r\n2.集合 - collection 【一对多】\r\n\r\n3.javaTape：用来指定实体类中属性的类型\r\n\r\n4.ofType：用来指定映射到List或者集合中的实体类类型，泛型中的约束类型\r\n\r\n## 动态SQL\r\n\r\n**什么是动态SQL：根据不同的条件生成不同的SQL**\r\n\r\n**所谓的动态SQl，本质还是SQL语句，只是我么可以在SQl层面，去执行一个逻辑代码**\r\n\r\n如果你之前用过 JSTL 或任何基于类 XML 语言的文本处理器，你对动态 SQL 元素可能会感觉似曾相识。在 MyBatis 之前的版本中，需要花时间了解大量的元素。借助功能强大的基于 OGNL 的表达式，MyBatis 3 替换了之前的大部分元素，大大精简了元素种类，现在要学习的元素种类比原来的一半还要少。\r\n\r\n- if\r\n\r\n- choose (when, otherwise)\r\n\r\n- trim (where, set)\r\n\r\n- foreach\r\n\r\n### if\r\n\r\n**BlogMapper.xml代码**\r\n\r\n```xml\r\n<select id=\"queryBlogIf\" parameterType=\"map\" resultType=\"Blog\">\r\n        select * from blog where 1 = 1\r\n        <if test=\"title != null\">\r\n            and title = #{title}\r\n        </if>\r\n        <if test=\"author != null\">\r\n            and author = #{author}\r\n        </if>\r\n    </select>\r\n```\r\n\r\n\r\n\r\n\r\n\r\n### choose、when、otherwise\r\n\r\n有时候，我们不想使用所有的条件，而只是想从多个条件中选择一个使用。针对这种情况，MyBatis 提供了 choose 元素，它有点像 Java 中的 switch 语句。\r\n\r\n还是上面的例子，但是策略变为：传入了 “title” 就按 “title” 查找，传入了 “author” 就按 “author” 查找的情形。若两者都没有传入，就返回标记为 featured 的 BLOG（这可能是管理员认为，与其返回大量的无意义随机 Blog，还不如返回一些由管理员挑选的 Blog）。\r\n\r\n```xml\r\n<select id=\"queryBlogChoose\" parameterType=\"map\" resultType=\"Blog\">\r\n        select * from blog\r\n        <where>\r\n            <choose>\r\n                <when test=\"title!=null\">\r\n                    title = #{title}\r\n                </when>\r\n                <when test=\"author!=null\">\r\n                    and author = #{author}\r\n                </when>\r\n                <otherwise>\r\n                    and views = #{views}\r\n                </otherwise>\r\n            </choose>\r\n        </where>\r\n    </select>\r\n```\r\n\r\n**只会选择其中一个条件实现，前面的实现后面的就不看了**\r\n\r\n\r\n\r\n### trim、where、set\r\n\r\n#### where\r\n\r\n如果没有匹配的条件会怎么样？最终这条 SQL 会变成这样：\r\n\r\n```xml\r\nSELECT * FROM BLOG\r\nWHERE\r\n```\r\n\r\n这会导致查询失败。如果匹配的只是第二个条件又会怎样？这条 SQL 会是这样:\r\n\r\n```xml\r\nSELECT * FROM BLOG\r\nWHERE\r\nAND title like ‘someTitle’\r\n```\r\n\r\n这个查询也会失败。这个问题不能简单地用条件元素来解决。这个问题是如此的难以解决，以至于解决过的人不会再想碰到这种问题。\r\n\r\nMyBatis 有一个简单且适合大多数场景的解决办法。而在其他场景中，可以对其进行自定义以符合需求。而这，只需要一处简单的改动：\r\n\r\n***where* 元素只会在子元素返回任何内容的情况下才插入 “WHERE” 子句。而且，若子句的开头为 “AND” 或 “OR”，*where* 元素也会将它们去除。**\r\n\r\n#### set\r\n\r\n用于动态更新语句的类似解决方案叫做 *set*。*set* 元素可以用于动态包含需要更新的列，忽略其它不更新的列。\r\n\r\n*set* 元素会动态地在行首插入 SET 关键字，并会删掉额外的逗号（这些逗号是在使用条件语句给列赋值时引入的）。\r\n\r\n```xml\r\n<update id=\"updateBlogSet\" parameterType=\"map\">\r\n        update blog\r\n        <set>\r\n            <if test=\"titlt != null\">\r\n                title = #{title},\r\n            </if>\r\n            <if test=\"author != null\">\r\n                author = #{author}\r\n            </if>\r\n        </set>\r\n        where id = #{id}\r\n    </update>\r\n```\r\n\r\n### SQL片段\r\n\r\n有的时候，我们可能将一些功能的部分抽取出来，方便复用\r\n\r\n1.使用`sql`标签抽取公共部分\r\n\r\n2.在需要使用的的地方使用`include`标签引用即可\r\n\r\n**注意事项**：\r\n\r\n1.最好基于单表来定义SQL！\r\n\r\n2.不要存在where\r\n\r\n\r\n\r\n### foreach\r\n\r\n*foreach* 元素的功能非常强大，它允许你指定一个集合，声明可以在元素体内使用的集合项（item）和索引（index）变量。它也允许你指定开头与结尾的字符串以及集合项迭代之间的分隔符。这个元素也不会错误地添加多余的分隔符，看它多智能！\r\n\r\n**提示** 你可以将任何可迭代对象（如 List、Set 等）、Map 对象或者数组对象作为集合参数传递给 *foreach*。当使用可迭代对象或者数组时，index 是当前迭代的序号，item 的值是本次迭代获取到的元素。当使用 Map 对象（或者 Map.Entry 对象的集合）时，index 是键，item 是值。\r\n\r\n```xml\r\n<select id=\"queryForeach\" parameterType=\"map\" resultType=\"Blog\">\r\n        select * from blog\r\n        <where>\r\n            <foreach collection=\"ids\" item=\"id\" open=\"and (\"\r\n                     close=\")\" separator=\"or\">\r\n                id = #{id}\r\n            </foreach>\r\n        </where>\r\n    </select>\r\n```\r\n\r\n\r\n\r\n\r\n\r\n## 缓存\r\n\r\n#### 简介\r\n\r\n1.什么是缓存？\r\n\r\n- 存在内存的临时数据\r\n- 将用户经常查询的数据放在缓存(内存)中，用户去查询数据就不用从磁盘上查询，从缓存中查询，从而提高查询效率，解决了高并发系统的性能问题\r\n\r\n2.为什么使用缓存？\r\n\r\n- 减少和数据库的交互次数，减少系统开销，提高系统效率\r\n\r\n3.什么样的数据能使用缓存\r\n\r\n- 经常查询并且不经常改变的数据\r\n\r\n#### MyBatis缓存\r\n\r\n- MyBatis包含了一个非常强大的查询缓存特性，它可以非常方便地定制和配置缓存。缓存可以极大的提升查询效率\r\n- MyBatis系统中定义了两级缓存：**一级缓存**和**二级缓存**\r\n  - 默认情况下，只有一级缓存开启。(SqlSession级别的缓存，也称本地缓存)\r\n  - 二级缓存需要手动开启和配置，他是基于namespace级别的缓存。\r\n  - 为了提高扩展性，Mybatis定义了缓存接口Cache。我们可以通过实现Cache接口来定义二级缓存。\r\n\r\n#### 一级缓存\r\n\r\n- 一级缓存也叫本地缓存：SqlSession\r\n  * 与数据库同一次会话期间查询到的数据会放在本地缓存中\r\n  * 以后如果需要获取相同的数据，直接从缓存中哪，没必要在去查询数据库\r\n\r\n**缓存失效的情况：**\r\n\r\n1.查询不同的东西\r\n\r\n2.增删改操作，可能会改变原来的数据，所有必定会刷新缓存！\r\n\r\n3.查询不同Mapper.xml\r\n\r\n4.手动清理缓存\r\n\r\n**小结**\r\n\r\n一级缓存默认是开启的，只在一次SqlSession中有效，也就是拿到连接到关闭连接这个去加段！\r\n\r\n\r\n\r\n#### 二级缓存\r\n\r\n- 二级缓存也叫全局缓存，一级缓存作用域太低了，所以诞生了二级缓存\r\n- 基于namespace级别的缓存，一个名门空间对应一个二级缓存\r\n- 工作机制：\r\n  - 一个会话查询一条数据，这个数据就会被放在当前会话的一级缓存中\r\n  - 如果当前会话关闭了，这个会话对应的一级缓存就没了，但是我们想要的是，会话关闭了，一级缓存中的数据保存到二级缓存中\r\n  - 新的会话查询信息，就可以从二级缓存中获取内容\r\n  - 不同的mapper查出的数据会放在自己对应的缓存中\r\n\r\n步骤：\r\n\r\n1.开启全局缓存\r\n\r\n```xml\r\n		<!--        开启全局缓存-->\r\n        <setting name=\"cacheEnabled\" value=\"true\"/>\r\n```\r\n\r\n2.在要使用二级缓存的Mapper中开启\r\n\r\n', '2021-03-14 18:12:30', 'https://cdn.jsdelivr.net/gh/zhangliyuangit/img/20210316130547.png', 1, 'MyBatis 本是apache的一个开源项目iBatis, 2010年这个项目由apache software foundation 迁移到了google code，并且改名为MyBatis 。2013年11月迁移到Github。iBATIS一词来源于“internet”和“abatis”的组合，是一个基于Java的持久层框架');
INSERT INTO `s_article` VALUES (4, 'Spring笔记', '# Spring\r\n\r\n## 简介\r\n\r\n- **简介**：Spring框架是由于软件开发的复杂性而创建的。Spring使用的是基本的JavaBean来完成以前只可能由EJB完成的事情。然而，Spring的用途不仅仅限于服务器端的开发。从简单性、可测试性和松耦合性角度而言，绝大部分Java应用都可以从\r\n\r\n- **Spring理念**：使现有的技术更加容易使用，本身是一个大杂烩，整合现有的技术框架！\r\n\r\n- **SSM**：SpringMvc + Spring +  Mybatis！\r\n\r\n```xml\r\n<!-- https://mvnrepository.com/artifact/org.springframework/spring-webmvc -->\r\n<dependency>\r\n    <groupId>org.springframework</groupId>\r\n    <artifactId>spring-webmvc</artifactId>\r\n    <version>5.2.6.RELEASE</version>\r\n</dependency>\r\n<!-- https://mvnrepository.com/artifact/org.springframework/spring-jdbc -->\r\n<dependency>\r\n    <groupId>org.springframework</groupId>\r\n    <artifactId>spring-jdbc</artifactId>\r\n    <version>5.2.6.RELEASE</version>\r\n</dependency>\r\n```\r\n\r\n- 优点：\r\n  1. Spring是一个开源的免费的框架(容器)！\r\n  2. Spring一个轻量级的、非入侵式的框架\r\n  3. 控制反转(IOC)，面向切面编程(AOP)\r\n  4. 支持事务的处理,对框架整合的支持\r\n- 总结：Spring就是一个轻量级的控制反转(IOC)和切面编程的框架！\r\n\r\n## 组成\r\n\r\n![](https://cdn.jsdelivr.net/gh/zhangliyuangit/img/20200601152845.png)\r\n\r\n**核心容器（Spring Core）**\r\n\r\n　　核心容器提供Spring框架的基本功能。Spring以bean的方式组织和管理Java应用中的各个组件及其关系。 \r\n\r\n**应用上下文（Spring Context）**\r\n\r\n　　Spring上下文是一个配置文件，向Spring框架提供上下文信息。Spring上下文包括企业服务，如JNDI、EJB、电子邮件、国际化、校验和调度功能。\r\n\r\n**Spring面向切面编程（Spring AOP）**\r\n\r\n　　通过配置管理特性，Spring AOP 模块直接将面向方面的编程功能集成到了 Spring框架中。所以，可以很容易地使 Spring框架管理的任何对象支持 AOP。Spring AOP 模块为基于 Spring 的应用程序中的对象提供了事务管理服务。通过使用 Spring AOP，不用依赖 EJB 组件，就可以将声明性事务管理集成到应用程序中。\r\n\r\n**JDBC和DAO模块（Spring DAO）**\r\n\r\n　　JDBC、DAO的抽象层提供了有意义的异常层次结构，可用该结构来管理异常处理，和不同数据库供应商所抛出的错误信息。异常层次结构简化了错误处理，并且极大的降低了需要编写的代码数量，比如打开和关闭链接。\r\n\r\n**对象实体映射（Spring ORM）**\r\n\r\n　　Spring框架插入了若干个ORM框架，从而提供了ORM对象的关系工具，其中包括了Hibernate、JDO和 IBatis SQL Map等，所有这些都遵从Spring的通用事物和DAO异常层次结构。\r\n\r\n**Web模块（Spring Web）**\r\n\r\n　　Web上下文模块建立在应用程序上下文模块之上，为基于web的应用程序提供了上下文。所以Spring框架支持与Struts集成，web模块还简化了处理多部分请求以及将请求参数绑定到域对象的工作。\r\n\r\n**MVC模块（Spring Web MVC）**\r\n\r\n　　MVC框架是一个全功能的构建Web应用程序的MVC实现。通过策略接口，MVC框架变成为高度可配置的。MVC容纳了大量视图技术，其中包括JSP、POI等，模型来有JavaBean来构成，存放于m当中，而视图是一个街口，负责实现模型，控制器表示逻辑代码，由c的事情。Spring框架的功能可以用在任何J2EE服务器当中，大多数功能也适用于不受管理的环境。Spring的核心要点就是支持不绑定到特定J2EE服务的可重用业务和数据的访问的对象，毫无疑问这样的对象可以在不同的J2EE环境，独立应用程序和测试环境之间重用。\r\n\r\n## IOC理论\r\n\r\n控制反转Ioc(Inversion of Control)，是一种设计思想，DI(依赖注入)式实现IoC的一种方法，也有人认为Di只是Ioc的另一种说法。没有IoC的程序中，我们使用面向对象编程，对象的创建与对象间的依赖关系完全硬编码在程序中，对象的创建由程序自己控制，控制反转后将对象创建转移给第三方，个人认为所谓的控制反转就是：获得依赖对象的方式反转了\r\n\r\n\r\n\r\n采用XML配置Bean的时候，Bean的定义信息是和实现分离的，而采用注入的方式可以把二者和为一体，Bean的定义信息直接以注解的形式定义在实现类中，从而达到零配置的目的\r\n\r\n\r\n\r\n**控制反转是一种通过描述(XML或注解)并通过第三方去生产或者获取特定对象的方式。在Spring中实现控制反转的是Ioc容器，其实现方法是依赖注入(Dependency Injection,DI)**\r\n\r\n由容器动态地将某种依赖关系注入到组件之间。\r\n控制反转也称为”依赖注入“（Dependency Injection DI)\r\n\r\n![](https://cdn.jsdelivr.net/gh/zhangliyuangit/img/20180731111256629.jpg)\r\n\r\nIoC/DI示例：\r\n依赖注入是Java编程思想中”面向接口编程“的体现，因此在设计程序是，对于程序所依赖的组件往往以忌口的形式出现，而不直接使用具体的实现类\r\n\r\n## 第一个Spring程序\r\n\r\n- **besns.xml**\r\n\r\n```xml\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\r\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\r\n        https://www.springframework.org/schema/beans/spring-beans.xsd\">\r\n    <bean id=\"user\" class=\"com.demospring.pojo.User\">\r\n        <property name=\"name\" value=\"Java\"/>\r\n    </bean>\r\n</beans>\r\n```\r\n\r\n- **测试代码**\r\n\r\n```java\r\nimport com.demospring.pojo.User;\r\nimport org.springframework.context.ApplicationContext;\r\nimport org.springframework.context.support.ClassPathXmlApplicationContext;\r\n\r\n/**\r\n * @author zhang\r\n * @date 2020/6/2 17:05\r\n */\r\npublic class MyTest {\r\n    public static void main(String[] args) {\r\n        ApplicationContext context = new ClassPathXmlApplicationContext(\"beans.xml\");\r\n        User user = (User) context.getBean(\"user\");\r\n        user.show();\r\n    }\r\n}\r\n```\r\n\r\n- **实体类**\r\n\r\n```java\r\npackage com.demospring.pojo;\r\n\r\n/**\r\n * @author zhang\r\n * @date 2020/6/2 17:03\r\n */\r\npublic class User {\r\n    private String name;\r\n\r\n    public String getName() {\r\n        return name;\r\n    }\r\n\r\n    public void setName(String name) {\r\n        this.name = name;\r\n    }\r\n\r\n    public void show(){\r\n        System.out.println(\"name--->\"+name);\r\n    }\r\n\r\n    @Override\r\n    public String toString() {\r\n        return \"User{\" +\r\n                \"name=\'\" + name + \'\\\'\' +\r\n                \'}\';\r\n    }\r\n}\r\n```\r\n\r\n**总结**：在配置文件加载的时候，容器中的管理对象就已经初始化了！\r\n\r\n## Spring配置\r\n\r\n### 别名\r\n\r\n```xml\r\n    <!--    别名，如果添加了别名，我们也可以使用别名获取到对象-->\r\n    <alias name=\"user\" alias=\"USER\"/>\r\n```\r\n\r\n### Bean的配置\r\n\r\n```xml\r\n<!--\r\n    id：Bean的唯一标识符，也就是相当于我们的对象名\r\n    class:对象对应的全限定名\r\n    name：也是别名\r\n    -->\r\n    <bean id=\"user\" class=\"com.demospring.pojo.User\">\r\n        <property name=\"name\" value=\"Java\"/>\r\n    </bean>\r\n```\r\n\r\n### import\r\n\r\n这个import一般用于团队开发使用，它可以将多个配置文件，导入合并为一个。\r\n\r\n## DI依赖注入\r\n\r\n### 构造器注入\r\n\r\n### Set方式注入【重点】\r\n\r\n实体类属性\r\n\r\n```java\r\nprivate String name;\r\n    private Address address;\r\n    private String[] books;\r\n    private List<String> hobbys;\r\n    private Map<String,String> card;\r\n    private Set<String> games;\r\n    private Properties info;\r\n    private String wife;\r\n```\r\n\r\nxml配置\r\n\r\n```xml\r\n<bean id=\"student\" class=\"com.demospring.pojo.Student\">\r\n        <property name=\"name\" value=\"张三\"/>\r\n        <property name=\"address\" ref=\"address\"></property>\r\n        <property name=\"books\">\r\n            <array>\r\n                <value>红楼梦</value>\r\n                <value>西游记</value>\r\n                <value>水浒传</value>\r\n                <value>三国演义</value>\r\n\r\n            </array>\r\n        </property>\r\n        <property name=\"hobbys\">\r\n            <list>\r\n                <value>打篮球</value>\r\n                <value>敲代码</value>\r\n                <value>看电影</value>\r\n            </list>\r\n        </property>\r\n        <property name=\"card\">\r\n            <map>\r\n                <entry key=\"身份证\" value=\"123456789\"/>\r\n                <entry key=\"银行卡\" value=\"987654321\"/>\r\n            </map>\r\n        </property>\r\n        <property name=\"games\">\r\n            <set>\r\n                <value>LOL</value>\r\n                <value>CS</value>\r\n                <value>PUBG</value>\r\n            </set>\r\n        </property>\r\n        <property name=\"wife\">\r\n            <null/>\r\n        </property>\r\n        <property name=\"info\">\r\n            <props>\r\n                <prop key=\"学号\">2019052531</prop>\r\n                <prop key=\"性别\">男</prop>\r\n            </props>\r\n        </property>\r\n    </bean>\r\n```\r\n\r\n\r\n\r\n### 拓展方式注入\r\n\r\n#### P命名空间注入\r\n\r\n需要添加xml约束\r\n\r\n`xmlns:p=\"http://www.springframework.org/schema/p\"`\r\n\r\n```xml\r\n    <!--    p命名空间注入，可以直接注入属性的值:property-->\r\n    <bean id=\"user\" class=\"com.demospring.pojo.User\" p:name=\"李四\" p:age=\"23\"/>\r\n```\r\n\r\n#### C命名空间注入\r\n\r\n需要添加xml约束\r\n\r\n`xmlns:c=\"http://www.springframework.org/schema/c\"`\r\n\r\n```xml\r\n    <!--    c命名空间注入，通过构造器注入：construct-args-->\r\n    <bean id=\"user1\" class=\"com.demospring.pojo.User\" c:name=\"王五\" c:age=\"38\"/>\r\n```\r\n\r\n\r\n\r\n### Bean的作用域\r\n\r\n| Scope                                                        | Description                                                  |\r\n| :----------------------------------------------------------- | :----------------------------------------------------------- |\r\n| [singleton](https://docs.spring.io/spring/docs/5.3.0-SNAPSHOT/spring-framework-reference/core.html#beans-factory-scopes-singleton) | (Default) Scopes a single bean definition to a single object instance for each Spring IoC container. |\r\n| [prototype](https://docs.spring.io/spring/docs/5.3.0-SNAPSHOT/spring-framework-reference/core.html#beans-factory-scopes-prototype) | Scopes a single bean definition to any number of object instances. |\r\n| [request](https://docs.spring.io/spring/docs/5.3.0-SNAPSHOT/spring-framework-reference/core.html#beans-factory-scopes-request) | Scopes a single bean definition to the lifecycle of a single HTTP request. That is, each HTTP request has its own instance of a bean created off the back of a single bean definition. Only valid in the context of a web-aware Spring `ApplicationContext`. |\r\n| [session](https://docs.spring.io/spring/docs/5.3.0-SNAPSHOT/spring-framework-reference/core.html#beans-factory-scopes-session) | Scopes a single bean definition to the lifecycle of an HTTP `Session`. Only valid in the context of a web-aware Spring `ApplicationContext`. |\r\n| [application](https://docs.spring.io/spring/docs/5.3.0-SNAPSHOT/spring-framework-reference/core.html#beans-factory-scopes-application) | Scopes a single bean definition to the lifecycle of a `ServletContext`. Only valid in the context of a web-aware Spring `ApplicationContext`. |\r\n| [websocket](https://docs.spring.io/spring/docs/5.3.0-SNAPSHOT/spring-framework-reference/web.html#websocket-stomp-websocket-scope) | Scopes a single bean definition to the lifecycle of a `WebSocket`. Only valid in the context of a web-aware Spring `ApplicationContext`. |\r\n\r\n1.单例模式(Spring默认机制)\r\n\r\n```xml\r\n    <bean id=\"user\" class=\"com.demospring.pojo.User\" p:name=\"李四\" p:age=\"23\" scope=\"singleton\"/>\r\n```\r\n\r\n2.原型模式：每次从容器get的时候，都会产生一个新对象！\r\n\r\n```xml\r\n    <bean id=\"user1\" class=\"com.demospring.pojo.User\" c:name=\"王五\" c:age=\"38\" scope=\"prototype\"/>\r\n```\r\n\r\n3.其余的request，session，application这些只能在web开发中用到\r\n\r\n## Bean的自动装配\r\n\r\n- 自动装配是Spring满足bean依赖的一种方式\r\n- Spring会在上下文中寻找，并自动给bean装配属性\r\n\r\n\r\n\r\n在Spring中有三种装配的方式\r\n\r\n1. 在xml中显式的配置\r\n2. 在java中显式的配置\r\n3. 隐式的自动装配bean【重要】\r\n\r\n\r\n\r\n### ByName自动装配\r\n\r\n```xml\r\n<bean id=\"people\" class=\"com.demospring.pojo.People\" autowire=\"byName\">\r\n        <property name=\"name\" value=\"张三\"/>\r\n    </bean>\r\n```\r\n\r\n`autowire=\"byName\"`\r\n\r\nByName：会自动在容器上下文中查找，和自己对象set方法后面的值对象的beanid！\r\n\r\n---\r\n\r\n### Bytype自动装配\r\n\r\n```xml\r\n<bean id=\"people\" class=\"com.demospring.pojo.People\" autowire=\"byType\">\r\n    <property name=\"name\" value=\"张三\"/>\r\n</bean>\r\n```\r\n\r\n`autowire=\"byType\"`\r\n\r\nByType：会自动在容器上下文中查找，和自己对象属性类型相同的bean\r\n\r\n**小结：**\r\n\r\n- byname的时候，需要保证所有bean的id唯一，并且这个bean需要和自动注入的属性的set方法的值一致！\r\n- bytype的时候，需要保证所有bean的class唯一，并且这个bean需要和自动注入的属性的类型一样\r\n\r\n### 使用注解实现自动装配\r\n\r\n1.导入约束：context约束\r\n\r\n2.配置注解的支持：<context:annotation-config/>\r\n\r\n```xml\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\r\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n    xmlns:context=\"http://www.springframework.org/schema/context\"\r\n    xsi:schemaLocation=\"http://www.springframework.org/schema/beans\r\n        https://www.springframework.org/schema/beans/spring-beans.xsd\r\n        http://www.springframework.org/schema/context\r\n        https://www.springframework.org/schema/context/spring-context.xsd\">\r\n\r\n    <context:annotation-config/>\r\n\r\n</beans>\r\n```\r\n\r\n\r\n\r\n**@Autowired**\r\n\r\n直接在属性上使用即可！也可以在set方法上使用\r\n\r\n```java\r\n	@Autowired\r\n    private Dog dog;\r\n    @Autowired\r\n    private Cat cat;\r\n    private String name;\r\n```\r\n\r\n使用Autowird我们可以不用编写Set方法了，前提是你这个自动装配的属性在IOC容器存在\r\n\r\n如果@Autowired自动装配的环境比较复杂，自动装配无法通过一个注解【@Autowired】完成的时候，我们可以使用@Qualifier(value=\"xxxx\")去配置@Autowired的使用，指定一个唯一的bean对象注入！\r\n\r\n## 使用注解开发\r\n\r\n在Spring4之后，需要使用注解开发，必须要保证aop的包导入了\r\n\r\n![](https://cdn.jsdelivr.net/gh/zhangliyuangit/img/20200604155231.png)\r\n\r\n使用注解需要导入context约束，增加注解的支持\r\n\r\n```xml\r\n<!--    指定要扫描的包，这个包下的注解就会生效-->\r\n    <context:component-scan base-package=\"com.demospring\"/>\r\n```\r\n\r\n\r\n\r\n> **@Component**:组件，放在类上，说明这个类被Spring管理了，就是Bean！\r\n\r\n---\r\n\r\n注入属性\r\n\r\n```java\r\n/**\r\n * @author zhang\r\n * @date 2020/6/4 16:00\r\n */\r\n\r\n//等价于    <bean id=\"user\" class=\"com.demospring.pojo.User\"></bean>\r\n@Component\r\npublic class User {\r\n    //相当于<property name=\"name\" value=\"张三\"/>\r\n    @Value(\"张三\")\r\n    public String name ;\r\n}\r\n\r\n```\r\n\r\n---\r\n\r\n衍生的注解\r\n\r\n@Component有几个衍生注解，我们在web开发中，会按照MVC三成架构分层	\r\n\r\n- dao【@Repository】\r\n- service【@Service】\r\n- controller【@Controller】\r\n\r\n这四个注解的功能都是一样的，都是代表将某个类注册到Spring容器中装配\r\n\r\n---\r\n\r\n作用域\r\n\r\n```java\r\n@Scope(\"prototype\")\r\n```\r\n\r\n\r\n\r\n## 使用Java的方式配置Spring\r\n\r\n```java\r\npackage com.demospring.config;\r\n\r\nimport com.demospring.pojo.User;\r\nimport org.springframework.context.annotation.Bean;\r\nimport org.springframework.context.annotation.Configuration;\r\n\r\n/**\r\n * @author zhang\r\n * @date 2020/6/4 17:42\r\n */\r\n//这个也会被Spring容器托管，注册到容器中，因为它本来就是一个@Component\r\n//@Configuration代表这是一个配置类，就和我们之前看的bean.xml\r\n@Configuration\r\npublic class MyConfig {\r\n    //注册一个Bean，就相当于我们之前写的一个bean标签\r\n    //这个方法的名字，就相当于bean标签中的id属性\r\n    //这个方法的返回值，就相当于bena标签的class属性\r\n    @Bean\r\n    public User getUser(){\r\n        return new User();//就是返回要注入到bean的对象！\r\n    }\r\n}\r\n```\r\n\r\n\r\n\r\n## AOP\r\n\r\n### 什么是AOP？\r\n\r\nAOP(Aspect Oriented Programming)意为：面向切面编程，通过预编译的方式和运行期动态代理实现程序功能的统一维护的一种技术。AOP是OOP的延续，是软件开发的一个热点，也是Spring框架的一个重要内容，是函数式编程的一种衍生泛型。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各个部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。\r\n\r\n![](https://cdn.jsdelivr.net/gh/zhangliyuangit/img/20200606155106.png)\r\n\r\n### AOP在Spring中的作用\r\n\r\n**提供声明式事务；允许用户自定义切面**\r\n\r\n\r\n\r\n1. 连接点(Joinpoint)： 所谓连接点是指那些被拦截到的点。在spring中,这些点指的是方法,因为spring只支持方法类型的连接点，也可以理解连接点为：目标类上哪些有可能被增强的方法。   \r\n2. 切点（Pointcut）：可以理解为查询条件。一个target（目标类）的所有方法都是连接点，切点可以通过查询条件定位特定的连接点。\r\n3. 增强（Advice）：织入目标类连接点上的一段程序代码。既包含连接点上的执行逻辑（横切逻辑、增强逻辑）又包含定位连接点的方位信息，before、after、around等。增强默认织入目标类的所有方法中。\r\n4. 目标对象（Target）：增强逻辑织入的目标类。\r\n5. 代理（Proxy）：一个类被AOP植入增强后，被产生一个结果代理类。\r\n6. 织入(Weaving)：将通知（增强）应用到连接点上，生成代理的过程。 \r\n7. 切面（Aspect)：由切点和增强组成。\r\n8. 引介（Introduction)**:**引介是一种特殊的通知在不修改类代码的前提下, Introduction可以在运行期为类动态地添加一些方法或Field。\r\n\r\n![](https://cdn.jsdelivr.net/gh/zhangliyuangit/img/20200606175926.png)\r\n\r\n**SpringAOP中，通过Advice定义横切逻辑，Spring中支持5种类型的Advice：**\r\n\r\n**前置增强**\r\n    BeforeAdvice  代表前置增强，因为spring只支持方法级的增强，所以MethodBeforeAdvice 是目前可用前置增强，表示在目标方法执行前实施增强。\r\n**后置增强**\r\n     AfterAdvice 代表后增强，表示目标方法在执行后实施增强 \r\n**环绕增强**\r\n     MethodInterceptor 代表环绕增强，表示目标方法执行前后实施增强\r\n**异常抛出增强**\r\n     ThrowsAdvice 代表抛出异常增强，表示目标方法抛出异常后实施增强\r\n**引介增强**\r\n     IntroductionInterceptor 代表引介增强，表示在目标类中添加一些新的方法和属性\r\n\r\n及AOP在不改变原来代码的情况下，去增加新的功能。\r\n\r\n\r\n\r\n### 使用Spring实现AOP\r\n\r\n使用AOP，需要导入一个依赖包！\r\n\r\n```xml\r\n<!-- https://mvnrepository.com/artifact/org.aspectj/aspectjweaver -->\r\n<dependency>\r\n    <groupId>org.aspectj</groupId>\r\n    <artifactId>aspectjweaver</artifactId>\r\n    <version>1.9.5</version>\r\n</dependency>\r\n```\r\n\r\n\r\n\r\n**方式一：使用Spring的API接口**\r\n\r\n```xml\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\r\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n       xmlns:aop=\"http://www.springframework.org/schema/aop\"\r\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\r\n        https://www.springframework.org/schema/beans/spring-beans.xsd\r\n        http://www.springframework.org/schema/aop\r\n        https://www.springframework.org/schema/aop/spring-aop.xsd\">\r\n\r\n\r\n    <!--    注册bean-->\r\n    <bean id=\"userService\" class=\"com.demo.service.UserServiceImpl\"/>\r\n    <bean id=\"log\" class=\"com.demo.log.Log\"/>\r\n    <bean id=\"afterLog\" class=\"com.demo.log.AfterLog\"/>\r\n\r\n\r\n    <!--    配置aop-->\r\n    <aop:config>\r\n        <!--        切入点 expression:表达式，execution（要执行的位置）-->\r\n        <aop:pointcut id=\"pointcut\" expression=\"execution(* com.demo.service.UserServiceImpl.*(..))\"/>\r\n\r\n        <!--        执行软绕增强-->\r\n        <aop:advisor advice-ref=\"log\" pointcut-ref=\"pointcut\"/>\r\n        <aop:advisor advice-ref=\"afterLog\" pointcut-ref=\"pointcut\"></aop:advisor>\r\n    </aop:config>\r\n</beans>\r\n```\r\n\r\n```java\r\n/**\r\n * @author zhang\r\n * @date 2020/6/6 16:15\r\n */\r\n\r\npublic class Log implements MethodBeforeAdvice {\r\n    //method:要执行的目标对象的方法\r\n    //args:参数\r\n    //o:目标对象\r\n    public void before(Method method, Object[] objects, Object o) throws Throwable {\r\n        System.out.println(o.getClass().getName()+\"的\"+method.getName()+\"被执行了\");\r\n\r\n    }\r\n}\r\n```\r\n\r\n测试方法\r\n\r\n```java\r\n/**\r\n * @author zhang\r\n * @date 2020/6/6 16:36\r\n */\r\npublic class MyTest {\r\n    public static void main(String[] args) {\r\n        ApplicationContext context = new ClassPathXmlApplicationContext(\"applicationContext.xml\");\r\n        //动态代理的式接口\r\n        UserService userService = (UserService) context.getBean(\"userService\");\r\n        userService.delete();\r\n    }\r\n}\r\n```\r\n\r\n**方式二：自定义来实现AOP【主要是切面定义】**\r\n\r\nDiyPointCut.java\r\n\r\n```java\r\n/**\r\n * @author zhang\r\n * @date 2020/6/6 17:48\r\n */\r\npublic class DiyPointCut {\r\n    public void before(){\r\n        System.out.println(\"==========方法执行前\");\r\n    }\r\n\r\n    public void after(){\r\n        System.out.println(\"==========方法执行后\");\r\n    }\r\n}\r\n```\r\n\r\nxml\r\n\r\n```xml\r\n<bean id=\"diy\" class=\"com.demo.diy.DiyPointCut\"/>\r\n    <aop:config>\r\n        <!-- 自定义切面 ref引用类-->\r\n        <aop:aspect ref=\"diy\">\r\n            <!--切入点-->\r\n            <aop:pointcut id=\"point\" expression=\"execution(* com.demo.service.UserServiceImpl.*(..))\"/>\r\n            <aop:before method=\"before\" pointcut-ref=\"point\"/>\r\n            <aop:after method=\"after\" pointcut-ref=\"point\"/>\r\n        </aop:aspect>\r\n    </aop:config>\r\n```\r\n\r\n**方式三：使用注解实现**\r\n\r\n```java\r\n/**\r\n * @author zhang\r\n * @date 2020/6/6 18:04\r\n */\r\n@Aspect//标注这个类是一个切面\r\n\r\npublic class AnnotationPointCut {\r\n    @Before(\"execution(* com.demo.service.UserServiceImpl.*(..))\")\r\n    public void before(){\r\n        System.out.println(\"----------方法执行前\");\r\n    }\r\n    @After(\"execution(* com.demo.service.UserServiceImpl.*(..))\")\r\n    public void after(){\r\n        System.out.println(\"---------方法执行后\");\r\n    }\r\n}\r\n```\r\n\r\n需要开启注解支持\r\n\r\n```xml\r\n<!--开启注解支持-->\r\n    <aop:aspectj-autoproxy/>\r\n```\r\n\r\n\r\n\r\n## 整合MyBatis\r\n\r\n步骤：\r\n\r\n1. 导入相关jar包\r\n   - junit\r\n   - mybatis\r\n   - mysql数据库\r\n   - spring相关的\r\n   - aop植入\r\n   - mybatis-spring【new】\r\n2. 编写配置文件\r\n3. 测试\r\n\r\n### 回忆MyBatis\r\n\r\n1. 编写实体类\r\n2. 编写核心配置文件\r\n3. 编写接口\r\n4. 编写Mapper.xml\r\n5. 测试\r\n\r\n\r\n\r\n### Mybatis-Spring\r\n\r\nMyBatis-Spring 会帮助你将 MyBatis 代码无缝地整合到 Spring 中。它将允许 MyBatis 参与到 Spring 的事务管理之中，创建映射器 mapper 和 `SqlSession` 并注入到 bean 中，以及将 Mybatis 的异常转换为 Spring 的 `DataAccessException`。最终，可以做到应用代码不依赖于 MyBatis，Spring 或 MyBatis-Spring。\r\n\r\n要使用 MyBatis-Spring 模块，只需要在类路径下包含 `mybatis-spring-2.0.5.jar` 文件和相关依赖即可。如果使用 Maven 作为构建工具，仅需要在 pom.xml 中加入以下代码即可：\r\n\r\n```xml\r\n<dependency>\r\n  <groupId>org.mybatis</groupId>\r\n  <artifactId>mybatis-spring</artifactId>\r\n  <version>2.0.5</version>\r\n</dependency>\r\n```\r\n\r\n步骤：\r\n\r\n1. 编写数据源\r\n2. sqlSessionfactory\r\n3. sqlSessionTemplate\r\n4. 需要接口加实现类\r\n5. 将自己写的实现类注入到spring中测试使用\r\n\r\n```xml\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\r\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\r\n        https://www.springframework.org/schema/beans/spring-beans.xsd\">\r\n\r\n    <!--DataSource:使用Spring的数据源替换Mybatis的配置-->\r\n    <bean id=\"datasource\" class=\"org.springframework.jdbc.datasource.DriverManagerDataSource\">\r\n        <property name=\"driverClassName\" value=\"com.mysql.cj.jdbc.Driver\"/>\r\n        <property name=\"url\" value=\"jdbc:mysql://localhost:3306/test1?serverTimezone=UTC\"/>\r\n        <property name=\"username\" value=\"root\"/>\r\n        <property name=\"password\" value=\"root\"/>\r\n    </bean>\r\n\r\n    <!--sqlSessionFactory-->\r\n    <bean id=\"sqlSessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\">\r\n        <property name=\"dataSource\" ref=\"datasource\"/>\r\n        <!--绑定MyBatis配置文件-->\r\n        <property name=\"configLocation\" value=\"classpath:mybatis-config.xml\"/>\r\n        <property name=\"mapperLocations\" value=\"classpath:com/demo/mapper/*.xml\"/>\r\n    </bean>\r\n\r\n    <!--sqlSessionTemplate就是我们使用的sqlSession-->\r\n    <bean id=\"sqlSession\" class=\"org.mybatis.spring.SqlSessionTemplate\">\r\n        <!--只能使用构造器注入 没有set方法-->\r\n        <constructor-arg index=\"0\" ref=\"sqlSessionFactory\"/>\r\n\r\n    </bean>\r\n    <bean id=\"teacherMapper\" class=\"com.demo.mapper.TeacherMapperImpl\">\r\n        <property name=\"sqlSession\" ref=\"sqlSession\"/>\r\n    </bean>\r\n</beans>\r\n```\r\n\r\nTeacherMapperImpl.java\r\n\r\n```java\r\n/**\r\n * @author zhang\r\n * @date 2020/6/7 18:42\r\n */\r\npublic class TeacherMapperImpl implements TeacherMapper{\r\n    //我们的所有操作都需要SqlSession来执行，现在使用SqlSessionTemplate\r\n    private SqlSessionTemplate sqlSession;\r\n\r\n    public void setSqlSession(SqlSessionTemplate sqlSession) {\r\n        this.sqlSession = sqlSession;\r\n    }\r\n\r\n    @Override\r\n    public List<Teacher> selectTeacher() {\r\n        TeacherMapper mapper = sqlSession.getMapper(TeacherMapper.class);\r\n        return mapper.selectTeacher();\r\n    }\r\n}\r\n```\r\n\r\n### SqlSessionDaoSupport\r\n\r\n`SqlSessionDaoSupport` 是一个抽象的支持类，用来为你提供 `SqlSession`。调用 `getSqlSession()` 方法你会得到一个 `SqlSessionTemplate`，之后可以用于执行 SQL 方法，就像下面这样:\r\n\r\n```java\r\npublic class UserDaoImpl extends SqlSessionDaoSupport implements UserDao {\r\n  public User getUser(String userId) {\r\n    return getSqlSession().selectOne(\"org.mybatis.spring.sample.mapper.UserMapper.getUser\", userId);\r\n  }\r\n}\r\n```\r\n\r\n在这个类里面，通常更倾向于使用 `MapperFactoryBean`，因为它不需要额外的代码。但是，如果你需要在 DAO 中做其它非 MyBatis 的工作或需要一个非抽象的实现类，那么这个类就很有用了。\r\n\r\n`SqlSessionDaoSupport` 需要通过属性设置一个 `sqlSessionFactory` 或 `SqlSessionTemplate`。如果两个属性都被设置了，那么 `SqlSessionFactory` 将被忽略。\r\n\r\n假设类 `UserMapperImpl` 是 `SqlSessionDaoSupport` 的子类，可以编写如下的 Spring 配置来执行设置：\r\n\r\n```xml\r\n<bean id=\"userDao\" class=\"org.mybatis.spring.sample.dao.UserDaoImpl\">\r\n  <property name=\"sqlSessionFactory\" ref=\"sqlSessionFactory\" />\r\n</bean>\r\n```\r\n\r\n\r\n\r\n\r\n\r\n## 声明式事务\r\n\r\n### 回顾事务\r\n\r\n- 把一组业务当成一个业务来做，要么都成功，要么都失败\r\n- 事务在项目开发中十分重要，涉及到数据的一致性问题，不能马虎\r\n- 确保完整性和一致性\r\n\r\n\r\n\r\n事务的ACID原则：\r\n\r\n- 原子性\r\n- 一致性\r\n- 隔离性\r\n- 持久性\r\n\r\n### Spring中事务管理\r\n\r\n- 声明式事务：AOP\r\n- 编程式事务：需要在代码中，进行事务的管理\r\n\r\n一个使用 MyBatis-Spring 的其中一个主要原因是它允许 MyBatis 参与到 Spring 的事务管理中。而不是给 MyBatis 创建一个新的专用事务管理器，MyBatis-Spring 借助了 Spring 中的 DataSourceTransactionManager 来实现事务管理。\r\n\r\n一旦配置好了 Spring 的事务管理器，你就可以在 Spring 中按你平时的方式来配置事务。并且支持 @Transactional 注解和 AOP 风格的配置。在事务处理期间，一个单独的 `SqlSession` 对象将会被创建和使用。当事务完成时，这个 session 会以合适的方式提交或回滚。\r\n\r\n事务配置好了以后，MyBatis-Spring 将会透明地管理事务。这样在你的 DAO 类中就不需要额外的代码了。\r\n\r\n### 标准配置\r\n\r\n要开启 Spring 的事务处理功能，在 Spring 的配置文件中创建一个 `DataSourceTransactionManager` 对象：\r\n\r\n```java\r\n<bean id=\"transactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\">\r\n  <constructor-arg ref=\"dataSource\" />\r\n</bean>\r\n@Bean\r\npublic DataSourceTransactionManager transactionManager() {\r\n  return new DataSourceTransactionManager(dataSource());\r\n}\r\n```\r\n\r\n传入的 `DataSource` 可以是任何能够与 Spring 兼容的 JDBC `DataSource`。包括连接池和通过 JNDI 查找获得的 `DataSource`。\r\n\r\n注意：为事务管理器指定的 `DataSource` **必须**和用来创建 `SqlSessionFactoryBean` 的是同一个数据源，否则事务管理器就无法工作了。\r\n\r\n```xml\r\n <!--配置声明式事务-->\r\n    <bean id=\"transactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\">\r\n        <constructor-arg ref=\"datasource\"/>\r\n    </bean>\r\n\r\n    <!--结合AOP实现事务的织入-->\r\n    <!--配置事务通知-->\r\n    <tx:advice id=\"txAdvice\" transaction-manager=\"transactionManager\">\r\n        <tx:attributes>\r\n            <tx:method name=\"add\" propagation=\"REQUIRED\"/>\r\n            <tx:method name=\"delete\"/>\r\n            <tx:method name=\"update\"/>\r\n            <tx:method name=\"*\"/>\r\n        </tx:attributes>\r\n    </tx:advice>\r\n    <!--配置事务切入-->\r\n    <aop:config>\r\n        <aop:pointcut id=\"txPointcut\" expression=\"execution(* com.demospring.Mapper.*.*(..))\"/>\r\n        <aop:advisor advice-ref=\"txAdvice\" pointcut-ref=\"txPointcut\"/>\r\n    </aop:config>\r\n```\r\n\r\n\r\n\r\n\r\n\r\n> 为什么需要事务？\r\n\r\n- 如果不配置事务，可能存在数据提交不一致情况\r\n- 如果我们不在Spring中去配置声明事务，我们就需要在代码中手动配置事务\r\n- 事务在项目的开发中十分重要，涉及到数据的一致性和完整性问题，不能马虎', '2021-03-14 18:13:32', 'https://cdn.jsdelivr.net/gh/zhangliyuangit/img/20210316100209.png', 1, 'Spring框架是由于软件开发的复杂性而创建的。Spring使用的是基本的JavaBean来完成以前只可能由EJB完成的事情。然而，Spring的用途不仅仅限于服务器端的开发。从简单性、可测试性和松耦合性角度而言，绝大部分Java应用都可以从Spring中受益。');
INSERT INTO `s_article` VALUES (5, 'SpringBoot笔记', '\r\n\r\n# SpringBoot\r\n\r\n### Spring优缺点\r\n\r\n#### 优点：\r\n\r\nSpring是java企业级的轻量代替品，Spring为企业级java开发提供了一种相对简单的方法，通过**依赖注入**和**面向切面编程**，用简单的java对象实现了EJB的功能。\r\n\r\n#### 缺点：\r\n\r\n虽然Spring的组件是轻量级的，但是Spring的配置文件确实重量级的，此外项目的依赖管理也是一件耗时耗力的事。\r\n\r\n### Spring的概述\r\n\r\nSpringBoot对上述Spring的缺点进行了改善了优化，基于**约定由于配置**的思想，可以让开发人员不必在配置与逻辑业务之间进行思维的切换，全身心的投入到逻辑业务的代码编写中。\r\n\r\n#### SpringBoot的优点\r\n\r\n- 为基于Spring的代码开发提供了更快的入门体验\r\n- 开箱即用，没有代码生成，也无需xml配置，同时可以修改默认值来满足特定的需求\r\n- 提供了一些大型项目中常见的非功能性特性，如嵌入式服务器，安全，指标，健康检测，外部配置等。\r\n- SpringBoot不是对Spring功能上的增强，而是提供了一种快速使用Spring的方式\r\n\r\n### SpringBoot的核心功能\r\n\r\n- 起步依赖\r\n\r\n起步依赖本质上是一个Maven项目对象模型，定义了对其他库的传递依赖，这些东西加载一起即支持某项功能。\r\n\r\n简单的说，起步依赖就是将具备某种功能的坐标打包到一起，并提供一些默认的功能。\r\n\r\n- 自动配置\r\n\r\nSpringBoot的自定配置是一个运行的过程，考虑了众多元素，才决定Spring配置中应该用哪个，不该用哪个，该过程是SpringBoot自动完成的。\r\n\r\n\r\n\r\n### SpringBoot原理分析\r\n\r\n#### 起步依赖\r\n\r\n按住Ctrl点击pom.xml中的spring-boot-starter-parent，跳转到了spring-boot-starter-parent的pom.xml，xml配置\r\n如下（只摘抄了部分重点配置）：\r\n\r\n```xml\r\n<parent>\r\n  <groupId>org.springframework.boot</groupId>\r\n  <artifactId>spring-boot-dependencies</artifactId>\r\n  <version>2.3.4.RELEASE</version>\r\n</parent>\r\n```\r\n\r\n按住Ctrl点击pom.xml中的spring-boot-starter-dependencies，跳转到了spring-boot-starter-dependencies的\r\npom.xml，xml配置如下（只摘抄了部分重点配置）：\r\n\r\n```xml\r\n<properties>\r\n  <activemq.version>5.15.13</activemq.version>\r\n  <antlr2.version>2.7.7</antlr2.version>\r\n  <appengine-sdk.version>1.9.82</appengine-sdk.version>\r\n  <artemis.version>2.12.0</artemis.version>\r\n  <aspectj.version>1.9.6</aspectj.version>\r\n  <assertj.version>3.16.1</assertj.version>\r\n  <atomikos.version>4.0.6</atomikos.version>\r\n  <awaitility.version>4.0.3</awaitility.version>\r\n  <bitronix.version>2.1.4</bitronix.version>\r\n  <build-helper-maven-plugin.version>3.1.0</build-helper-maven-plugin.version>\r\n  <byte-buddy.version>1.10.14</byte-buddy.version>\r\n  <caffeine.version>2.8.5</caffeine.version>\r\n  <cassandra-driver.version>4.6.1</cassandra-driver.version>\r\n  <classmate.version>1.5.1</classmate.version>\r\n  <commons-codec.version>1.14</commons-codec.version>\r\n  <commons-dbcp2.version>2.7.0</commons-dbcp2.version>\r\n  <commons-lang3.version>3.10</commons-lang3.version>\r\n  <commons-pool.version>1.6</commons-pool.version>\r\n  <commons-pool2.version>2.8.1</commons-pool2.version>\r\n  <couchbase-client.version>3.0.8</couchbase-client.version>\r\n  <db2-jdbc.version>11.5.4.0</db2-jdbc.version>\r\n```\r\n\r\n从上面的spring-boot-starter-dependencies的pom.xml中我们可以发现，一部分的坐标版本、管理依赖、插件管理已经定义好了，所有我们的SpringBoot工程继承spring-boot-stater-parent后已经具备版本锁定等配置了。所有起步依赖的作用就是进行依赖的传递。\r\n\r\n### 自动配置\r\n\r\n按住Ctrl点击查看启动类MySpringBootApplication上的注解@SpringBootApplication\r\n\r\n\r\n\r\n```java\r\n@SpringBootApplication\r\npublic class Springdemo02Application {\r\n\r\n    public static void main(String[] args) {\r\n        SpringApplication.run(Springdemo02Application.class, args);\r\n    }\r\n}\r\n```\r\n\r\n注解@SpringBootApplication的源码\r\n\r\n```java\r\n@Target({ElementType.TYPE})\r\n@Retention(RetentionPolicy.RUNTIME)\r\n@Documented\r\n@Inherited\r\n@SpringBootConfiguration\r\n@EnableAutoConfiguration\r\n@ComponentScan(\r\n    excludeFilters = {@Filter(\r\n    type = FilterType.CUSTOM,\r\n    classes = {TypeExcludeFilter.class}\r\n), @Filter(\r\n    type = FilterType.CUSTOM,\r\n    classes = {AutoConfigurationExcludeFilter.class}\r\n)}\r\n)\r\npublic @interface SpringBootApplication {\r\n    @AliasFor(\r\n        annotation = EnableAutoConfiguration.class\r\n    )\r\n    Class<?>[] exclude() default {};\r\n\r\n    @AliasFor(\r\n        annotation = EnableAutoConfiguration.class\r\n    )\r\n    String[] excludeName() default {};\r\n\r\n    @AliasFor(\r\n        annotation = ComponentScan.class,\r\n        attribute = \"basePackages\"\r\n    )\r\n    String[] scanBasePackages() default {};\r\n\r\n    @AliasFor(\r\n        annotation = ComponentScan.class,\r\n        attribute = \"basePackageClasses\"\r\n    )\r\n    Class<?>[] scanBasePackageClasses() default {};\r\n\r\n    @AliasFor(\r\n        annotation = ComponentScan.class,\r\n        attribute = \"nameGenerator\"\r\n    )\r\n    Class<? extends BeanNameGenerator> nameGenerator() default BeanNameGenerator.class;\r\n\r\n    @AliasFor(\r\n        annotation = Configuration.class\r\n    )\r\n    boolean proxyBeanMethods() default true;\r\n}\r\n```\r\n\r\n其中，\r\n@SpringBootConfiguration：等同与@Configuration，既标注该类是Spring的一个配置类\r\n@EnableAutoConfiguration：SpringBoot自动配置功能开启\r\n按住Ctrl点击查看注解@EnableAutoConfiguration\r\n\r\n```java\r\n@Target({ElementType.TYPE})\r\n@Retention(RetentionPolicy.RUNTIME)\r\n@Documented\r\n@Inherited\r\n@AutoConfigurationPackage\r\n@Import({AutoConfigurationImportSelector.class})\r\npublic @interface EnableAutoConfiguration {\r\n    String ENABLED_OVERRIDE_PROPERTY = \"spring.boot.enableautoconfiguration\";\r\n\r\n    Class<?>[] exclude() default {};\r\n\r\n    String[] excludeName() default {};\r\n}\r\n```\r\n\r\n\r\n\r\n### SpringBoot工程热部署\r\n\r\n\r\n\r\n在pom.xml中添加(也可在创建SpringBoot项目的时候勾选)\r\n\r\n```xml\r\n<!-- 热部署 -->\r\n<dependency>\r\n    <groupId>org.springframework.boot</groupId>\r\n    <artifactId>spring-boot-devtools</artifactId>\r\n    <scope>runtime</scope>\r\n    <optional>true</optional>\r\n</dependency>\r\n```\r\n\r\n对idea进行配置\r\n\r\n![](https://cdn.jsdelivr.net/gh/zhangliyuangit/img/20201012185929.png)\r\n\r\n然后 Shift+Ctrl+Alt+/，选择Registry\r\n\r\n![](https://cdn.jsdelivr.net/gh/zhangliyuangit/img/20201012190038.png)\r\n\r\n勾选\r\n\r\n![image-20201012190119999](C:\\Users\\49572\\AppData\\Roaming\\Typora\\typora-user-images\\image-20201012190119999.png)\r\n\r\n\r\n\r\n### SpringBoot配置文件\r\n\r\nSpringBoot是基于约定的，所有很多配置都有默认值，但如果相使用自己的配置替换默认配置的话，就可以使用application.properties或者application.yml进行配置。\r\n\r\n#### 自定义配置\r\n\r\n配置文件与配置类的映射方式\r\n\r\n```yml\r\nperson:\r\n  name: zhangsan\r\n  age: 20\r\n```\r\n\r\n#### 使用@Value来映射\r\n\r\n我们可以通过@Value注解将配置文件中的值映射到一个Spring管理的Bean的字段上\r\n\r\n```java\r\n/**\r\n * @author zhang\r\n * @date 2020/10/10 9:39\r\n */\r\n@Controller\r\npublic class HelloController {\r\n\r\n    @Value(\"${person.name}\")\r\n    private String name;\r\n    @Value(\"${person.age}\")\r\n    private int age;\r\n\r\n\r\n    @ResponseBody\r\n    @RequestMapping(\"/index\")\r\n    public String index(){\r\n        System.out.println(name + \"---------\" + age);\r\n        return \"Hello Spring Boot\";\r\n    }\r\n}\r\n```\r\n\r\n#### 使用@ConfigurationProperties\r\n\r\n先导入依赖\r\n\r\n```xml\r\n<dependency>\r\n            <groupId> org.springframework.boot </groupId>\r\n            <artifactId> spring-boot-configuration-processor 	</artifactId>\r\n            <optional> true </optional>\r\n</dependency>\r\n```\r\n\r\n测试类(提供set方法)\r\n\r\n```java\r\n/**\r\n * @author zhang\r\n * @date 2020/10/10 9:39\r\n */\r\n@Controller\r\n@ConfigurationProperties(prefix = \"person\")\r\npublic class HelloController {\r\n\r\n    private String name;\r\n    private int age;\r\n\r\n\r\n    @ResponseBody\r\n    @RequestMapping(\"/index\")\r\n    public String index(){\r\n        System.out.println(name + \"---------\" + age);\r\n        return \"Hello Spring Boot\";\r\n    }\r\n\r\n\r\n    public void setName(String name) {\r\n        this.name = name;\r\n    }\r\n\r\n    public void setAge(int age) {\r\n        this.age = age;\r\n    }\r\n}\r\n```\r\n\r\n\r\n\r\n\r\n\r\n### 整合Myabtis\r\n\r\n添加Mybatis起步依赖和数据库驱动\r\n\r\n```xml\r\n<!--mybatis-->\r\n<dependency>\r\n    <groupId>org.mybatis.spring.boot</groupId>\r\n    <artifactId>mybatis-spring-boot-starter</artifactId>\r\n    <version>2.1.0</version>\r\n</dependency>\r\n<!--驱动-->\r\n<dependency>\r\n    <groupId>mysql</groupId>\r\n    <artifactId>mysql-connector-java</artifactId>\r\n    <version>8.0.17</version>\r\n</dependency>\r\n```\r\n\r\n在application.yml中添加数据库配置信息\r\n\r\n```yml\r\n#数据源\r\nspring:\r\n  datasource:\r\n    driver-class-name: com.mysql.cj.jdbc.Driver\r\n    url: jdbc:mysql://localhost:3306/study?serverTimezone=Asia/Shanghai&useUnicode=true&characterEncoding=utf8\r\n    username: root\r\n    password: root\r\n```\r\n\r\n在application.yml中添加mybatis配置信息\r\n\r\n```yml\r\n#mybatis配置\r\nmybatis:\r\n  #别名\r\n  type-aliases-package: com.gem.springdemo1.entity\r\n  #扫描mapper\r\n  mapper-locations: classpath:com/gem/springdemo1/mapper/*Mapper.xml\r\n  configuration:\r\n    log-impl: org.apache.ibatis.logging.log4j.Log4jImpl\r\n```\r\n\r\nSpringBoot默认使用logback作为日志打印工具，我们要想查看sql语句，需要使用log4j\r\n\r\n导入log4j的起步依赖\r\n\r\n```xml\r\n<!-- log4j -->\r\n<dependency>\r\n    <groupId>org.springframework.boot</groupId>\r\n    <artifactId>spring-boot-starter-log4j</artifactId>\r\n    <version>1.3.8.RELEASE</version>\r\n    <!-- 修复重复绑定报红的问题-->\r\n    <exclusions>\r\n        <exclusion>\r\n            <groupId>org.slf4j</groupId>\r\n            <artifactId>slf4j-log4j12</artifactId>\r\n        </exclusion>\r\n    </exclusions>\r\n</dependency>\r\n```\r\n\r\n在application.yml中配置\r\n\r\n```yml\r\nmybatis:\r\n configuration:\r\n    log-impl: org.apache.ibatis.logging.log4j.Log4jImpl\r\n```\r\n\r\n\r\n\r\n### 整合Junit\r\n\r\n添加依赖\r\n\r\n```xml\r\n<!-- 测试启动器 -->\r\n<dependency>\r\n    <groupId>org.springframework.boot</groupId>\r\n    <artifactId>spring-boot-starter-test</artifactId>\r\n    <scope>test</scope>\r\n</dependency>\r\n```\r\n\r\n在测试类上加上对应的注解\r\n\r\n```java\r\n@SpringBootTest(classes = Springdemo1Application.class)\r\n@RunWith(SpringRunner.class)\r\n```\r\n\r\n\r\n\r\n### 静态资源\r\n\r\n在SpringBoot中有四个目录可以放我们的静态资源\r\n\r\n				- \"classpath:/META-INF/resources/\"\r\n				- \"classpath:/resources/\"\r\n				- \"classpath:/static/\"\r\n				- \"classpath:/public/\"\r\n\r\n例如\r\n\r\n![](https://cdn.jsdelivr.net/gh/zhangliyuangit/img/20201012204129.png)\r\n\r\n**网站图标的说明**\r\n\r\n与其他静态资源一样，Spring Boot在配置的静态内容位置中查找 favicon.ico。如果存在这样的文件，它将自动用作应用程序的favicon。\r\n\r\n1、关闭SpringBoot默认图标\r\n\r\n```properties\r\n#关闭默认图标\r\nspring.mvc.favicon.enabled=false\r\n```\r\n\r\n2、自己放一个图标在静态资源目录下\r\n\r\n\r\n\r\n### Thymeleaf模板引擎\r\n\r\njsp支持非常强大的功能，包括能写Java代码，但是呢，我们现在的这种情况，SpringBoot这个项目首先是以jar的方式，不是war，像第二，我们用的还是嵌入式的Tomcat，所以呢，**他现在默认是不支持jsp的**。**SpringBoot推荐你可以来使用模板引擎**\r\n\r\n引入Thymeleaf\r\n\r\n```xml\r\n<!-- thymeleaf模板引擎 -->\r\n<dependency>\r\n    <groupId>org.springframework.boot</groupId>\r\n    <artifactId>spring-boot-starter-thymeleaf</artifactId>\r\n</dependency>\r\n```\r\n\r\n创建一个Controller，model添加一个User实体，返回hello.html\r\n\r\n```java\r\n/**\r\n * @author zhang\r\n * @date 2020/10/12 9:42\r\n */\r\n@Controller\r\npublic class HelloController {\r\n\r\n    @RequestMapping(\"/index\")\r\n    public String index(Model model){\r\n        User user = new User(1L,\"张三\",new Date());\r\n        model.addAttribute(\"user\",user);\r\n        model.addAttribute(\"num\",10);\r\n        model.addAttribute(\"gender\",\"w\");\r\n        return \"hello\";\r\n    }\r\n}\r\n```\r\n\r\n在hello.html中获取数据\r\n\r\n在html中引入Thymeleaf\r\n\r\n```html\r\n<html lang=\"en\" xmlns:th=\"http://www.thymeleaf.org\">\r\n```\r\n\r\n在标签中取值使用th:text(写在标签体中)，使用#datas.format来格式化时间\r\n\r\n处理字符串和数字类型同理\r\n\r\n```xml\r\n<div>\r\n    <p th:text=\"${user.id}\"></p>\r\n    <p th:text=\"${user.username}\"></p>\r\n    <p th:text=\"${#dates.format(user.createDate,\'yyyy-MM-dd HH:mm:ss\')}\"></p>\r\n</div>\r\n```\r\n\r\n如果是表单标签使用th:value设置值\r\n\r\n```html\r\n<input type=\"text\" th:value=\"${user.id}\">\r\n```\r\n\r\n单选框使用th:attr设置属性\r\n\r\n```html\r\n<input name=\"gender\" type=\"radio\" th:attr=\"checked=${gender eq \'m\'?true:false}\">男\r\n    <input name=\"gender\" type=\"radio\" th:attr=\"checked=${gender eq \'w\'?true:false}\">女\r\n```\r\n\r\n#### if\r\n\r\n```html\r\n<div>\r\n    <p th:if=\"${num == 10}\">num:10</p>\r\n    <p th:if=\"${num == 20}\">num:20</p>\r\n    <p th:if=\"${num == 30}\">num:30</p>\r\n\r\n</div>\r\n```\r\n\r\n#### switch case\r\n\r\n```html\r\n<div th:switch=\"${num}\">\r\n    <p th:case=\"10\">num为10</p>\r\n    <p th:case=\"20\">num为20</p>\r\n    <p th:case=\"30\">num为30</p>\r\n</div>\r\n```\r\n\r\n\r\n\r\n#### each\r\n\r\n编写一个controller，模拟数据查询到的list\r\n\r\n```java\r\n/**\r\n * @author zhang\r\n * @date 2020/10/12 15:54\r\n */\r\n@Controller\r\n@RequestMapping(\"/user\")\r\npublic class UserController {\r\n    @RequestMapping(\"/userList\")\r\n    public String userList(Model model){\r\n        List<User> list = new ArrayList<>();\r\n        list.add(new User(1L,\"张三\",new Date()));\r\n        list.add(new User(2L,\"李四\",new Date()));\r\n        list.add(new User(3L,\"王五\",new Date()));\r\n        list.add(new User(4L,\"赵六\",new Date()));\r\n        list.add(new User(5L,\"田七\",new Date()));\r\n\r\n        model.addAttribute(\"userList\",list);\r\n        return \"user\";\r\n    }\r\n}\r\n```\r\n\r\nhtml代码\r\n\r\n```html\r\n<table>\r\n    <tr>\r\n        <th>编号</th>\r\n        <th>姓名</th>\r\n        <th>创建时间</th>\r\n        <th>操作</th>\r\n    </tr>\r\n    <tr th:each=\"u:${userList}\">\r\n        <td th:text=\"${u.id}\"></td>\r\n        <td th:text=\"${u.username}\"></td>\r\n        <td th:text=\"${#dates.format(u.createDate,\'yyyy-MM-dd\')}\"></td>\r\n        <td>\r\n            <a th:href=\"@{/user/edit(id=${u.id})}\" th:text=\"编辑\"></a>\r\n            <a th:href=\"@{\'/user/delete/\' + ${u.id}}\" th:text=\"删除\"></a>\r\n        </td>\r\n    </tr>\r\n</table>\r\n```\r\n\r\n#### url、href、src问题\r\n\r\n**原始？传参版本使用th:href动态的写，参数使用()传递**\r\n\r\n```html\r\n<a th:href=\"@{/user/edit(id=${u.id})}\" th:text=\"编辑\"></a>\r\n```\r\n\r\nController\r\n\r\n```java\r\n@RequestMapping(\"/edit\")\r\npublic String editUser(int id){\r\n    System.out.println(\"要修改的id是\" + id);\r\n    return \"user\";\r\n}\r\n```\r\n\r\n**Rest风格**\r\n\r\n```html\r\n<a th:href=\"@{\'/user/delete/\' + ${u.id}}\" th:text=\"删除\"></a>\r\n```\r\n\r\nController\r\n\r\n```java\r\n@RequestMapping(\"/delete/{id}\")\r\npublic String deleteUser(@PathVariable(\"id\") int id){\r\n    System.out.println(\"要删除的id是:\" + id);\r\n    return \"user\";\r\n}\r\n```\r\n\r\n使用{参数}表示展位符，使用@pathVaiable注解获取url中占位符，并且绑定到方法的参数上。\r\n\r\n**引入css**\r\n\r\n```html\r\n<link rel=\"stylesheet\" th:href=\"@{/css/style.css}\">\r\n```\r\n\r\n\r\n\r\n\r\n\r\n### 全局异常处理\r\n\r\n@ControllerAdvice搭配@ExceptionHandler注解\r\n\r\n```java\r\n@ControllerAdvice\r\npublic class WebException {\r\n    @ExceptionHandler(value = Exception.class)\r\n    public ModelAndView defaultException(Exception e, HttpServletRequest request){\r\n        ModelAndView mv=new ModelAndView();\r\n        mv.setViewName(\"error\");\r\n        //异常对象\r\n        mv.addObject(\"exception\",e);\r\n        //异常请求\r\n        mv.addObject(\"url\",request.getRequestURI());\r\n        return  mv;\r\n    }\r\n```', '2021-03-14 18:14:26', 'https://cdn.jsdelivr.net/gh/zhangliyuangit/img/20210316100324.png', 1, 'Spring Boot是由Pivotal团队提供的全新框架，其设计目的是用来简化新Spring应用的初始搭建以及开发过程。该框架使用了特定的方式来进行配置，从而使开发人员不再需要定义样板化的配置');
INSERT INTO `s_article` VALUES (6, 'SpringBoot整合md', '# SpringBoot集成editor.md\r\n\r\n- - \r\n\r\nEditor.md——功能非常丰富的编辑器，左端编辑，右端预览，非常方便，完全免费。\r\n\r\n[官网]: https://pandao.github.io/editor.md/\r\n\r\n### 基础工程搭建\r\n\r\narticle：文章表\r\n\r\n| 字段    | 类型     | 备注         |\r\n| ------- | -------- | ------------ |\r\n| id      | int      | 文章的唯一ID |\r\n| author  | varchar  | 作者         |\r\n| title   | varchar  | 标题         |\r\n| content | longtext | 文章的内容   |\r\n\r\n建表SQL：\r\n\r\n```sql\r\nCREATE TABLE `article` (\r\n`id` int(10) NOT NULL AUTO_INCREMENT COMMENT \'int文章的唯一ID\',\r\n`author` varchar(50) NOT NULL COMMENT \'作者\',\r\n`title` varchar(100) NOT NULL COMMENT \'标题\',\r\n`content` longtext NOT NULL COMMENT \'文章的内容\',\r\nPRIMARY KEY (`id`)\r\n) ENGINE=InnoDB DEFAULT CHARSET=utf8\r\n```\r\n\r\n实体类\r\n\r\n```java\r\n//文章类\r\n@Data\r\n@NoArgsConstructor\r\n@AllArgsConstructor\r\npublic class Article implements Serializable {\r\n\r\n   private int id; //文章的唯一ID\r\n   private String author; //作者名\r\n   private String title; //标题\r\n   private String content; //文章的内容\r\n\r\n}\r\n```\r\n\r\nmapper接口\r\n\r\n```java\r\n@Mapper\r\n@Repository\r\npublic interface ArticleMapper {\r\n   //查询所有的文章\r\n   List<Article> queryArticles();\r\n\r\n   //新增一个文章\r\n   int addArticle(Article article);\r\n\r\n   //根据文章id查询文章\r\n   Article getArticleById(int id);\r\n\r\n   //根据文章id删除文章\r\n   int deleteArticleById(int id);\r\n\r\n}\r\n```\r\n\r\n```xml\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\"\r\n       \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\">\r\n\r\n<mapper namespace=\"com.kuang.mapper.ArticleMapper\">\r\n\r\n   <select id=\"queryArticles\" resultType=\"Article\">\r\n      select * from article\r\n   </select>\r\n   \r\n   <select id=\"getArticleById\" resultType=\"Article\">\r\n      select * from article where id = #{id}\r\n   </select>\r\n   \r\n   <insert id=\"addArticle\" parameterType=\"Article\">\r\n      insert into article (author,title,content) values (#{author},#{title},#{content});\r\n   </insert>\r\n   \r\n   <delete id=\"deleteArticleById\" parameterType=\"int\">\r\n      delete from article where id = #{id}\r\n   </delete>\r\n   \r\n</mapper>\r\n```\r\n\r\n### 文章编辑整合\r\n\r\n下载好的项目结构\r\n\r\n![](https://cdn.jsdelivr.net/gh/zhangliyuangit/img/20201013193552.png)\r\n\r\n进入`examples`文件夹css和js文件夹粘到项目的static文件夹下，另外粘贴项目根目录下的css文件夹的editormd.css和js文件夹下的editormd.js，最后把整个lib也粘贴过来。\r\n\r\n项目路径\r\n\r\n![](https://cdn.jsdelivr.net/gh/zhangliyuangit/img/20201013194022.png)\r\n\r\n编辑文章页面 editor.html、需要引入 jQuery；\r\n\r\n需要修改css和js的路径，和**path**的路径\r\n\r\n```html\r\n<!DOCTYPE html>\r\n<html class=\"x-admin-sm\" lang=\"zh\" xmlns:th=\"http://www.thymeleaf.org\">\r\n\r\n<head>\r\n    <meta charset=\"UTF-8\">\r\n    <title>demo</title>\r\n    <meta name=\"renderer\" content=\"webkit\">\r\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\">\r\n    <meta name=\"viewport\" content=\"width=device-width,user-scalable=yes, minimum-scale=0.4, initial-scale=0.8,target-densitydpi=low-dpi\" />\r\n    <!--Editor.md-->\r\n    <link rel=\"stylesheet\" th:href=\"@{/css/style.css}\">\r\n    <link rel=\"stylesheet\" th:href=\"@{/css/editormd.css}\"/>\r\n    <link rel=\"shortcut icon\" href=\"https://pandao.github.io/editor.md/favicon.ico\" type=\"image/x-icon\" />\r\n</head>\r\n\r\n<body>\r\n\r\n<div class=\"layui-fluid\">\r\n    <div class=\"layui-row layui-col-space15\">\r\n        <div class=\"layui-col-md12\">\r\n            <!--博客表单-->\r\n            <form name=\"mdEditorForm\">\r\n                <div>\r\n                    标题：<input type=\"text\" name=\"title\">\r\n                </div>\r\n                <div>\r\n                    作者：<input type=\"text\" name=\"author\">\r\n                </div>\r\n                <div id=\"article-content\">\r\n                    <textarea name=\"content\" id=\"content\" style=\"display:none;\"> </textarea>\r\n                </div>\r\n            </form>\r\n        </div>\r\n    </div>\r\n</div>\r\n</body>\r\n\r\n<!--editormd-->\r\n<script th:src=\"@{/js/jquery.min.js}\"></script>\r\n<script th:src=\"@{/js/editormd.js}\"></script>\r\n\r\n<script type=\"text/javascript\">\r\n    var testEditor;\r\n\r\n    //window.onload = function(){ }\r\n    $(function() {\r\n        testEditor = editormd(\"article-content\", {\r\n            width : \"100%\",\r\n            height : 600,\r\n            syncScrolling : \"single\",\r\n            path : \"../lib/\",\r\n            saveHTMLToTextarea : true,    // 保存 HTML 到 Textarea\r\n            emoji: true,\r\n            theme: \"default\",//工具栏主题\r\n            previewTheme: \"default\",//预览主题\r\n            editorTheme: \"pastel-on-default\",//编辑主题\r\n            tex : true,                   // 开启科学公式TeX语言支持，默认关闭\r\n            flowChart : true,             // 开启流程图支持，默认关闭\r\n            sequenceDiagram : true,       // 开启时序/序列图支持，默认关闭,\r\n            //图片上传\r\n            imageUpload : true,\r\n            imageFormats : [\"jpg\", \"jpeg\", \"gif\", \"png\", \"bmp\", \"webp\"],\r\n            imageUploadURL : \"/article/file/upload\",\r\n            onload : function() {\r\n                console.log(\'onload\', this);\r\n            },\r\n            /*指定需要显示的功能按钮*/\r\n            toolbarIcons : function() {\r\n                return [\"undo\",\"redo\",\"|\",\r\n                    \"bold\",\"del\",\"italic\",\"quote\",\"ucwords\",\"uppercase\",\"lowercase\",\"|\",\r\n                    \"h1\",\"h2\",\"h3\",\"h4\",\"h5\",\"h6\",\"|\",\r\n                    \"list-ul\",\"list-ol\",\"hr\",\"|\",\r\n                    \"link\",\"reference-link\",\"image\",\"code\",\"preformatted-text\",\r\n                    \"code-block\",\"table\",\"datetime\",\"emoji\",\"html-entities\",\"pagebreak\",\"|\",\r\n                    \"goto-line\",\"watch\",\"preview\",\"fullscreen\",\"clear\",\"search\",\"|\",\r\n                    \"help\",\"info\",\"releaseIcon\", \"index\"]\r\n            },\r\n\r\n            /*自定义功能按钮，下面我自定义了2个，一个是发布，一个是返回首页*/\r\n            toolbarIconTexts : {\r\n                releaseIcon : \"<span bgcolor=\\\"gray\\\">发布</span>\",\r\n                index : \"<span bgcolor=\\\"red\\\">返回首页</span>\",\r\n            },\r\n\r\n            /*给自定义按钮指定回调函数*/\r\n            toolbarHandlers:{\r\n                releaseIcon : function(cm, icon, cursor, selection) {\r\n                    //表单提交\r\n                    mdEditorForm.method = \"post\";\r\n                    mdEditorForm.action = \"/article/addArticle\";//提交至服务器的路径\r\n                    mdEditorForm.submit();\r\n                },\r\n                index : function(){\r\n                    window.location.href = \'/\';\r\n                },\r\n            }\r\n        });\r\n    });\r\n</script>\r\n\r\n</html>\r\n```\r\n\r\n编写Controller，进行跳转，以及保存文章\r\n\r\n```java\r\n@Controller\r\n@RequestMapping(\"/article\")\r\npublic class ArticleController {\r\n\r\n   @GetMapping(\"/toEditor\")\r\n   public String toEditor(){\r\n       return \"editor\";\r\n  }\r\n   \r\n   @PostMapping(\"/addArticle\")\r\n   public String addArticle(Article article){\r\n       articleMapper.addArticle(article);\r\n       return \"editor\";\r\n  }\r\n}\r\n```\r\n\r\n### 文章展示\r\n\r\ncontroller增加方法\r\n\r\n```java\r\n@GetMapping(\"/{id}\")\r\npublic String show(@PathVariable(\"id\") int id,Model model){\r\n   Article article = articleMapper.getArticleById(id);\r\n   model.addAttribute(\"article\",article);\r\n   return \"article\";\r\n}\r\n```\r\n\r\n编写页面 article.html\r\n\r\n```html\r\n<!DOCTYPE html>\r\n<html lang=\"en\" xmlns:th=\"http://www.thymeleaf.org\">\r\n<head>\r\n    <meta charset=\"UTF-8\">\r\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1, maximum-scale=1\">\r\n    <title th:text=\"${article.title}\"></title>\r\n</head>\r\n<body>\r\n\r\n<div>\r\n    <!--文章头部信息：标题，作者，最后更新日期，导航-->\r\n    <h2 style=\"margin: auto 0\" th:text=\"${article.title}\"></h2>\r\n    作者：<span style=\"float: left\" th:text=\"${article.author}\"></span>\r\n    <!--文章主体内容-->\r\n    <div id=\"doc-content\" style=\"width: 80%;margin-left: 10%\">\r\n        <textarea style=\"display:none;\" placeholder=\"markdown\" th:text=\"${article.content}\"></textarea>\r\n    </div>\r\n\r\n</div>\r\n\r\n<link rel=\"stylesheet\" th:href=\"@{/editormd/css/editormd.preview.css}\" />\r\n<script th:src=\"@{/js/jquery.min.js}\"></script>\r\n<script th:src=\"@{/lib/marked.min.js}\"></script>\r\n<script th:src=\"@{/lib/prettify.min.js}\"></script>\r\n<script th:src=\"@{/lib/raphael.min.js}\"></script>\r\n<script th:src=\"@{/lib/underscore.min.js}\"></script>\r\n<script th:src=\"@{/lib/sequence-diagram.min.js}\"></script>\r\n<script th:src=\"@{/lib/flowchart.min.js}\"></script>\r\n<script th:src=\"@{/lib/jquery.flowchart.min.js}\"></script>\r\n<script th:src=\"@{/js/editormd.js}\"></script>\r\n\r\n<script type=\"text/javascript\">\r\n    var testEditor;\r\n    $(function () {\r\n        testEditor = editormd.markdownToHTML(\"doc-content\", {//注意：这里是上面DIV的id\r\n            htmlDecode: \"style,script,iframe\",\r\n            emoji: true,\r\n            taskList: true,\r\n            tocm: true,\r\n            tex: true, // 默认不解析\r\n            flowChart: true, // 默认不解析\r\n            sequenceDiagram: true, // 默认不解析\r\n            codeFold: true\r\n        });});\r\n</script>\r\n</body>\r\n</html>\r\n```\r\n\r\n同样需要修改js和css\r\n\r\n', '2021-03-17 18:15:33', 'https://cdn.jsdelivr.net/gh/zhangliyuangit/img/20210316100324.png', 1, 'Editor.md 是一个可嵌入的开源 Markdown 在线编辑器组件，你可以很方便用在浏览器、NW.js（Node-webkit）等地方，基于CodeMirror、jQuery 和 Marked 构建。');
INSERT INTO `s_article` VALUES (7, '数据结构', '# 数据结构\r\n\r\n### 队列\r\n\r\n- 队列是一个有序列表，可以用**数组**或者**链表**实现。(数组实现是顺序存储，链表实现是链式存储)。\r\n- 遵循**先入先出**的原则，及现存如的数据，要先取出。后存入的数据要后取出。\r\n\r\n#### 数组模拟队列\r\n\r\n![](https://cdn.jsdelivr.net/gh/zhangliyuangit/img/未命名文件.png)\r\n\r\n代码实现\r\n\r\n```java\r\npackage day1队列;\r\n\r\n/**\r\n * @author zhang\r\n * @date 2020/12/15 20:55\r\n */\r\npublic class ArrayQueueDemo {\r\n    public static void main(String[] args) {\r\n        ArrayQueue queue = new ArrayQueue(3);\r\n        queue.addQueue(1);\r\n        queue.addQueue(2);\r\n        queue.addQueue(3);\r\n        System.out.println(queue.headQueue());\r\n        //queue.showQueue();\r\n        int i = queue.getQueue();\r\n        //queue.showQueue();\r\n        System.out.println(queue.headQueue());\r\n    }\r\n}\r\n\r\nclass ArrayQueue{\r\n    private int maxSize;//最大容量\r\n    private int front;//队列头\r\n    private int rear;//队列尾\r\n    private int[] arr;//该数组用于存放数据，模拟队列\r\n\r\n    public ArrayQueue(int maxSize){\r\n        this.maxSize = maxSize;\r\n        this.arr = new int[maxSize];\r\n        front = -1;//指向队列头部，分析出front是指向队列头的前一个位置\r\n        rear = -1;\r\n    }\r\n\r\n    //判断队列是否满\r\n    public boolean isFull(){\r\n        return rear == maxSize - 1;\r\n    }\r\n\r\n    //判断队列是否为空\r\n    public boolean isEmpty(){\r\n        return rear == front;\r\n    }\r\n\r\n    //添加数据到队列\r\n    public void addQueue(int n){\r\n        //判断队列是否满了\r\n        if (isFull()){\r\n            System.out.println(\"队列已经满了\");\r\n            return;\r\n        }\r\n        rear++;\r\n        arr[rear] = n;\r\n    }\r\n\r\n    //数据取出队列，出队列\r\n    public int getQueue(){\r\n        //判断数组是否为空\r\n        if (isEmpty()){\r\n            //抛出异常\r\n            throw new RuntimeException(\"队列为空，不能取数据\");\r\n        }\r\n\r\n        front++;\r\n        return arr[front];\r\n    }\r\n\r\n    //显示队列的所有数据\r\n    public void showQueue(){\r\n        if (isEmpty()){\r\n            System.out.println(\"队列为空，没有数据\");\r\n            return;\r\n        }\r\n        //Arrays.toString(arr);\r\n        for (int i = front + 1; i < arr.length; i++) {\r\n            System.out.println(arr[i]);\r\n        }\r\n    }\r\n\r\n    //显示对头数据\r\n    public int headQueue(){\r\n        if (isEmpty()){\r\n            throw new RuntimeException(\"队列空的，没有数据\");\r\n        }\r\n        return arr[front + 1];\r\n    }\r\n\r\n}\r\n\r\n```\r\n\r\n数据不能重复使用。\r\n\r\n\r\n\r\n#### 数组模拟环形队列\r\n\r\n> 思路调整\r\n\r\n1. front变量的含义做一个调整:front就是指向队列的第一个元素，front的初始值为0。\r\n2. rear变量的含义做一个调整:rear指向队列的最后元素的后一个位置，rear的初始值为0。\r\n3. 当队列满时，条件是(rear + 1) % maxSize = front\r\n4. 队列为空时，条件是rear == front\r\n5. 队列中有效数据的个数(rear + maxSize - front) % maxSize\r\n\r\n代码实现\r\n\r\n```java\r\npackage day1队列;\r\n\r\n/**\r\n * @author zhang\r\n * @date 2020/12/15 22:23\r\n */\r\npublic class CircleArrayQueueDemo {\r\n    public static void main(String[] args) {\r\n        CircleArrayQueue queue = new CircleArrayQueue(4);//有效数据最大是3\r\n        queue.addQueue(1);\r\n        queue.addQueue(2);\r\n        queue.addQueue(3);\r\n        int i = queue.getQueue();\r\n        int i2 = queue.getQueue();\r\n        queue.showQueue();\r\n        System.out.println(queue.size());\r\n        System.out.println(queue.headQueue());\r\n    }\r\n}\r\n\r\nclass CircleArrayQueue{\r\n    private int maxSize;//最大容量\r\n    private int front;//队列头\r\n    private int rear;//队列尾\r\n    private int[] arr;//该数组用于存放数据，模拟队列\r\n\r\n    public CircleArrayQueue(int maxSize){\r\n        this.maxSize = maxSize;\r\n        this.arr = new int[maxSize];\r\n        front = 0;//指向队列头部，分析出front是指向队列头的前一个位置\r\n        rear = 0;\r\n    }\r\n\r\n    //判断队列是否满\r\n    public boolean isFull(){\r\n        return (rear + 1) % maxSize == front;\r\n    }\r\n\r\n    //判断队列是否为空\r\n    public boolean isEmpty(){\r\n        return rear == front;\r\n    }\r\n\r\n    //添加数据到队列\r\n    public void addQueue(int n){\r\n        //判断队列是否满了\r\n        if (isFull()){\r\n            System.out.println(\"队列已经满了\");\r\n            return;\r\n        }\r\n        arr[rear] = n;\r\n        //将rear后移\r\n        rear = (rear + 1) % maxSize;\r\n    }\r\n\r\n    //数据取出队列，出队列\r\n    public int getQueue(){\r\n        //判断数组是否为空\r\n        if (isEmpty()){\r\n            //抛出异常\r\n            throw new RuntimeException(\"队列为空，不能取数据\");\r\n        }\r\n\r\n        int val = arr[front];\r\n        //front后移\r\n        front = (front + 1) % maxSize;\r\n        return val;\r\n    }\r\n\r\n    //显示队列的所有数据\r\n    public void showQueue(){\r\n        if (isEmpty()){\r\n            System.out.println(\"队列为空，没有数据\");\r\n            return;\r\n        }\r\n        //Arrays.toString(arr);\r\n        for (int i = front ; i < front + size(); i++) {\r\n            System.out.printf(\"arr[%d]=%d\\n\",i % maxSize,arr[i % maxSize]);\r\n        }\r\n    }\r\n\r\n    //显示对头数据\r\n    public int headQueue(){\r\n        if (isEmpty()){\r\n            throw new RuntimeException(\"队列空的，没有数据\");\r\n        }\r\n        return arr[front];\r\n    }\r\n\r\n    //求出当前队列有效数据的个数\r\n    public int size(){\r\n        return (rear + maxSize - front) % maxSize;\r\n    }\r\n\r\n}\r\n\r\n```\r\n\r\n\r\n\r\n### 链表\r\n\r\n![链表物理结构示意图](https://cdn.jsdelivr.net/gh/zhangliyuangit/img/未命名文件 (1).png)\r\n\r\n![逻辑结构示意图](https://cdn.jsdelivr.net/gh/zhangliyuangit/img/未命名文件 (2).png)\r\n\r\n- 链表以节点的方式来存储，是链式存储。\r\n- 每个节点包含data域，next域(指向下一个节点)。\r\n- **内内地址不一定连续**。\r\n- 链表分为**带头结点的链表**和**不带头节点的链表**。\r\n\r\n\r\n\r\n#### 单链表的实际应用\r\n\r\n> 使用带头结点的**单链表**实现-水浒英雄排行榜管理\r\n>\r\n> 1）完成对英雄人物的增删改查\r\n>\r\n> 2）第一种方式在添加英雄时，根据排名将英雄插入到链表的尾部\r\n>\r\n> 3）第二种方式在添加英雄时，根据排名将英雄插入到指定位置\r\n\r\n![](https://cdn.jsdelivr.net/gh/zhangliyuangit/img/未命名文件 (3).png)\r\n\r\n```java\r\npackage day2链表;\r\n\r\n/**\r\n * @author zhang\r\n * @date 2020/12/16 22:33\r\n */\r\npublic class SingleLinkedListDemo {\r\n    public static void main(String[] args) {\r\n        SingleLinkedList singleLinkedList = new SingleLinkedList();\r\n        singleLinkedList.add(new HeroNode(1,\"松江\",\"及时雨\"));\r\n        singleLinkedList.add(new HeroNode(2,\"卢俊义\",\"玉麒麟\"));\r\n        singleLinkedList.add(new HeroNode(3,\"吴用\",\"智多星\"));\r\n        singleLinkedList.add(new HeroNode(4,\"林冲\",\"豹子头\"));\r\n        singleLinkedList.list();\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * 定义一个SingleLinedList管理我们的英雄\r\n */\r\nclass SingleLinkedList{\r\n\r\n    //初始化一个头节点\r\n    private HeroNode head = new HeroNode(0,\"\",\"\");\r\n\r\n    /**\r\n     *  添加节点到单链表\r\n     *  1.找到当前链表的的最后节点(next为空)\r\n     *  2.将最后节点的next指向新的节点\r\n     */\r\n    public void add(HeroNode heroNode){\r\n        HeroNode temp = head;\r\n        while (temp.next != null){\r\n            //后移\r\n            temp = temp.next;\r\n        }\r\n        temp.next = heroNode;\r\n    }\r\n\r\n    public void list(){\r\n        //判断链表是否为空\r\n        if (head.next == null){\r\n            System.out.println(\"链表为空\");\r\n            return;\r\n        }\r\n        //头节点不能动，需要一个辅助变量来遍历\r\n        HeroNode temp = head;\r\n        while (temp.next != null){\r\n            System.out.println(temp.next);\r\n            //将next后移\r\n            temp = temp.next;\r\n        }\r\n    }\r\n\r\n}\r\n\r\n/**\r\n * 每一个英雄都是一个节点\r\n */\r\nclass HeroNode{\r\n    public int no;\r\n    public String name;\r\n    public String nickName;\r\n    public HeroNode next;//指向下一个节点\r\n\r\n\r\n    public HeroNode(int no,String name,String nickName){\r\n        this.no = no;\r\n        this.name = name;\r\n        this.nickName = nickName;\r\n    }\r\n\r\n    @Override\r\n    public String toString() {\r\n        return \"HeroNode{\" +\r\n                \"no=\" + no +\r\n                \", name=\'\" + name + \'\\\'\' +\r\n                \", nickName=\'\" + nickName + \'\\\'\' +\r\n                \'}\';\r\n    }\r\n}\r\n```\r\n\r\n**第二种方式在添加英雄时，根据排名将英雄插入到指定位置**\r\n\r\n\r\n```java\r\n/**\r\n * 第二种方式在添加英雄时，根据排名将英雄插入到指定位置\r\n */\r\npublic void addByOrder(HeroNode heroNode){\r\n    HeroNode temp = head;\r\n    boolean flag = false;//表示添加的编号是否存在默认为false\r\n    while (true){\r\n        if (temp.next == null){\r\n            //说明temp已经在链表的最后面了\r\n            break;\r\n        }\r\n        if (temp.next.no > heroNode.no){\r\n            //位置找到，就在temp的后面插入\r\n            break;\r\n        }\r\n        else if (temp.next.no == heroNode.no){\r\n            //说明要添加的编号已经存在了\r\n            flag = true;\r\n            break;\r\n        }\r\n        //后移，遍历链表\r\n        temp = temp.next;\r\n    }\r\n\r\n    if (flag == true){\r\n        System.out.printf(\"待插入的英雄的编号[%d]已经存在了，不能加入\\n\",heroNode.no);\r\n    }else {\r\n        //新的节点的next指向temp.next\r\n        //temp.next等于新的节点\r\n        heroNode.next = temp.next;\r\n        temp.next = heroNode;\r\n    }\r\n}\r\n```\r\n\r\n**删除节点**\r\n\r\n![](https://cdn.jsdelivr.net/gh/zhangliyuangit/img/asfaszxZXsaasd.png)\r\n\r\n思路：\r\n\r\n1. 首先找到要删除节点的前一个节点temp\r\n2. temp.next = temp.next.next\r\n3. 被删除的节点，没有任何引用指向它，将会被GC回收\r\n\r\n代码实现\r\n\r\n```java\r\npublic void delete(int no){\r\n    HeroNode temp = head;\r\n    boolean flag = false;//表示是否找到待删除节点\r\n    while (true){\r\n        if (temp.next == null){\r\n            //已经到链表的最后了\r\n            break;\r\n        }\r\n        if (temp.next.no == no){\r\n            //说明找到了待删除节点的前一个节点temp\r\n            flag = true;\r\n            break;\r\n        }\r\n        temp = temp.next;\r\n    }\r\n\r\n    if (flag){\r\n        //找到\r\n        temp.next = temp.next.next;\r\n    }else {\r\n        System.out.printf(\"没有找到待删除的节点[%d]\\n\",no);\r\n    }\r\n}\r\n```\r\n\r\n\r\n\r\n#### 单链表常见面试题\r\n\r\n**1.单链表的反转**\r\n\r\n![](https://cdn.jsdelivr.net/gh/zhangliyuangit/img/assdfsdfsdhfgthrt.png)\r\n\r\n思路：\r\n\r\n- 先定义一个节点reverseHead = new Node();\r\n- 从头到尾遍历原来的链表，每遍历一个节点，就将其取出，并放在新链表reverseHead的最前端\r\n- 原来的链表的head.next = reverseHead.next\r\n\r\n\r\n\r\n\r\n\r\n#### 双向链表\r\n\r\n![](https://cdn.jsdelivr.net/gh/zhangliyuangit/img/a1111kjsdljflsdjgsdf.png)\r\n\r\n代码实现\r\n\r\n```java\r\npackage day3双向列表;\r\n\r\n/**\r\n * @author zhang\r\n * @date 2020/12/27 17:17\r\n */\r\npublic class DoubleLinkedListDemo {\r\n    public static void main(String[] args) {\r\n        DoubleLindedList doubleLindedList = new DoubleLindedList();\r\n        doubleLindedList.add(new Node(1,\"宋江\"));\r\n        doubleLindedList.add(new Node(2,\"卢俊义\"));\r\n        doubleLindedList.add(new Node(3,\"吴用\"));\r\n        doubleLindedList.add(new Node(4,\"林冲\"));\r\n\r\n        doubleLindedList.list();\r\n\r\n        doubleLindedList.update(new Node(3,\"公孙胜\"));\r\n        doubleLindedList.list();\r\n\r\n        doubleLindedList.delete(2);\r\n        doubleLindedList.list();\r\n\r\n    }\r\n}\r\n\r\n//创建一个双向链表的类\r\nclass DoubleLindedList{\r\n    private Node head = new Node(0,\"\");\r\n\r\n\r\n    //返回头节点\r\n    public Node getHead(){\r\n        return head;\r\n    }\r\n\r\n    //遍历双向链表的一个方法\r\n    public void list(){\r\n        //判断链表是否为空\r\n        if (head.next == null){\r\n            System.out.println(\"链表为空\");\r\n            return;\r\n        }\r\n\r\n        Node temp = head.next;\r\n        while (true){\r\n            //判断链表是否到最后\r\n            if (temp.next == null){\r\n                break;\r\n            }\r\n            //输出节点信息\r\n            System.out.println(temp);\r\n            //节点后移\r\n            temp = temp.next;\r\n        }\r\n    }\r\n\r\n    //添加一个节点到双向链表的最后\r\n    public void add(Node node){\r\n        Node temp = head;\r\n        //遍历节点，找到最后\r\n        while (true){\r\n            //找到链表最后\r\n            if (temp.next == null){\r\n                break;\r\n            }\r\n            temp = temp.next;\r\n        }\r\n        //形成一个双向链表\r\n        temp.next = node;\r\n        node.pre = temp;\r\n    }\r\n\r\n    //修改一个节点的内容\r\n    public void update(Node node){\r\n        //判断是否为空\r\n        if (head.next == null){\r\n            System.out.println(\"链表为空\");\r\n            return;\r\n        }\r\n        Node temp = head;\r\n        boolean flag = false;//表示是否找到该节点\r\n        while (true){\r\n            if (temp == null){\r\n                break;\r\n            }\r\n            if (temp.no == node.no){\r\n                flag = true;\r\n                break;\r\n            }\r\n            temp = temp.next;\r\n        }\r\n\r\n        if (flag){\r\n            temp.name = node.name;\r\n        }else {\r\n            System.out.printf(\"没有找到编号为[%d]的节点\",node.no);\r\n        }\r\n\r\n    }\r\n\r\n    /**\r\n     *   删除一个节点\r\n     *   对于双向链表，我们直接找到要删除的节点，找到后自我删除即可\r\n     */\r\n    public void delete(int no){\r\n        //判断当前链表是否为空\r\n        if (head.next == null){\r\n            System.out.println(\"链表为空,无法删除\");\r\n            return;\r\n        }\r\n        Node temp = head.next;\r\n        boolean flag = false;\r\n        while (true){\r\n            if (temp == null){\r\n                //已经到链表的最后节点的next\r\n                break;\r\n            }\r\n            if (temp.no == no){\r\n                //找到待删除的节点\r\n                flag = true;\r\n                break;\r\n            }\r\n            //temp后移\r\n            temp = temp.next;\r\n        }\r\n        if (flag){\r\n            //删除\r\n            temp.pre.next = temp.next;\r\n            //这样有风险，如果是最后一个节点，就不需要执行，否则空指针异常\r\n            if (temp.next != null){\r\n                temp.next.pre = temp.pre;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nclass Node{\r\n    public int no;\r\n    public String name;\r\n    public Node next;//指向下一个节点,默认为null\r\n    public Node pre;//指向前一个节点，默认为null\r\n\r\n    public Node(int no, String name) {\r\n        this.no = no;\r\n        this.name = name;\r\n    }\r\n\r\n    @Override\r\n    public String toString() {\r\n        return \"Node{\" +\r\n                \"no=\" + no +\r\n                \", name=\'\" + name + \'\\\'\' +\r\n                \'}\';\r\n    }\r\n}\r\n\r\n\r\n```\r\n\r\n\r\n\r\n#### 单向环形链表\r\n\r\n![](https://cdn.jsdelivr.net/gh/zhangliyuangit/img/shujujiegou01.png)\r\n\r\n\r\n\r\n##### 约瑟夫问题\r\n\r\n> 约瑟夫环是一个数学的应用问题：已知n个人（以编号1，2，3...n分别表示）围坐在一张圆桌周围。从编号为k的人开始报数，数到m的那个人出列；他的下一个人又从1开始报数，数到m的那个人又出列；依此规律重复下去，直到圆桌周围的人全部出列。\r\n\r\n\r\n\r\n假设**n=5**，即有5个人。\r\n\r\n**k=1**，从第一个人开始报数\r\n\r\n**m=2**，数两下\r\n\r\n![](https://cdn.jsdelivr.net/gh/zhangliyuangit/img/shujujiegou02.png)\r\n\r\n![](https://cdn.jsdelivr.net/gh/zhangliyuangit/img/shujujiegou03.png)\r\n\r\n![](https://cdn.jsdelivr.net/gh/zhangliyuangit/img/shujujiegou04.png)\r\n\r\n![](https://cdn.jsdelivr.net/gh/zhangliyuangit/img/shujujiegou05.png)\r\n\r\n![](https://cdn.jsdelivr.net/gh/zhangliyuangit/img/shujujiegou06.png)\r\n\r\n**构建一个单向循环链表的的思路**(curNode的next指向新的元素，新的元素的next指向first，curNode后移)\r\n\r\n1. 先构建第一个节点，让first指向该节点，并形成环。\r\n2. 后面我们没创建一个新的节点，就把该节点，加入到已有的环形链表即可\r\n\r\n\r\n\r\n**遍历环形链表**\r\n\r\n1. 先让一个辅助指针指向first节点\r\n2. 后通过一个while循环遍历该环形链表即可(current.next == first)\r\n\r\n\r\n\r\n**出圈**\r\n\r\n![](https://cdn.jsdelivr.net/gh/zhangliyuangit/img/shujujiegou07.png)\r\n\r\n\r\n\r\n```java\r\npackage day4单向循环链表;\r\n\r\n/**\r\n * @author zhang\r\n * @date 2020/12/27 20:39\r\n */\r\npublic class Josepfu {\r\n    public static void main(String[] args) {\r\n        CircleSingleLinkedList circleSingleLinkedList = new CircleSingleLinkedList();\r\n        circleSingleLinkedList.addNode(5);//加入5个节点\r\n        //circleSingleLinkedList.list();\r\n\r\n        //测试出圈\r\n        circleSingleLinkedList.out(1,2,5);\r\n    }\r\n}\r\n\r\n//创建一个环形的单向链表\r\nclass CircleSingleLinkedList{\r\n    //创建一个first节点，当前没有编号\r\n    private Node first = null;\r\n\r\n    //添加node节点，构建成一个环形链表\r\n    public void addNode(int nums){\r\n        //数据校验\r\n        if (nums < 1){\r\n            throw new RuntimeException(\"非法参数\");\r\n        }\r\n        Node curNode = null;//辅助指针\r\n        for (int i = 1; i <= nums; i++) {\r\n            //根据编号创建node节点\r\n            Node node = new Node(i);\r\n            //如果是第一个node\r\n            if (i == 1){\r\n                first = node;\r\n                first.setNext(first);//构成一个环，只是环中只有一个元素\r\n                curNode = first;//curNode指向第一个节点\r\n            }else {\r\n                curNode.setNext(node);\r\n                node.setNext(first);\r\n                curNode = node;\r\n            }\r\n        }\r\n    }\r\n\r\n    //遍历当前环形链表\r\n    public void list(){\r\n        //判空\r\n        if (first == null){\r\n            System.out.println(\"链表为空\");\r\n            return;\r\n        }\r\n\r\n        //first不能动，使用辅助指针完成遍历\r\n        Node curNode = first;\r\n        while (true){\r\n            System.out.printf(\"NODE节点的编号 %d \\n\",curNode.getNo());\r\n\r\n            if (curNode.getNext() == first){\r\n                //说明遍历完毕\r\n                break;\r\n            }\r\n            //后移\r\n            curNode = curNode.getNext();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * 根据用户的输入，计算出出圈的顺序\r\n     * @param startNode 从第几个节点开始\r\n     * @param countNum  表示数几下\r\n     * @param nums      表示最初有多少节点在圈中\r\n     */\r\n    public void out(int startNode,int countNum,int nums){\r\n        //数据校验\r\n        if (first == null || startNode < 1 || startNode > nums){\r\n            throw new RuntimeException(\"非法参数\");\r\n        }\r\n\r\n        //创建一个辅助指针\r\n        Node helper = first;\r\n        //让helper指向了最后一个节点\r\n        while (helper.getNext() != first) {\r\n            helper = helper.getNext();\r\n        }\r\n        //报数之前，first和helper先移动k-1次\r\n        for (int i = 0; i < startNode - 1; i++) {\r\n            first = first.getNext();\r\n            helper = helper.getNext();\r\n        }\r\n\r\n        //当小孩报数时，让first和helper指针移动m-1次，然后出圈\r\n        while (true){\r\n            if (helper == first){\r\n                //说明圈中只有一个节点\r\n                break;\r\n            }\r\n            for (int i = 0; i < countNum - 1; i++) {\r\n                first = first.getNext();\r\n                helper = helper.getNext();\r\n            }\r\n            //这是first指向的节点，就是要出圈的节点\r\n            System.out.printf(\"节点%d出圈 \\n\",first.getNo());\r\n\r\n            first = first.getNext();\r\n            helper.setNext(first);\r\n        }\r\n        System.out.printf(\"最后留在圈中的节点 %d \\n\",first.getNo());\r\n\r\n    }\r\n}\r\n\r\n\r\n//节点类\r\nclass Node{\r\n    private int no;\r\n    private Node next;//下一个节点，默认是null\r\n\r\n    public Node(int no){\r\n        this.no = no;\r\n    }\r\n\r\n    public int getNo() {\r\n        return no;\r\n    }\r\n\r\n    public void setNo(int no) {\r\n        this.no = no;\r\n    }\r\n\r\n    public Node getNext() {\r\n        return next;\r\n    }\r\n\r\n    public void setNext(Node next) {\r\n        this.next = next;\r\n    }\r\n}\r\n\r\n```\r\n\r\n![](https://cdn.jsdelivr.net/gh/zhangliyuangit/img/shuju08.png)\r\n\r\n\r\n\r\n\r\n\r\n### 栈(stack)\r\n\r\n\r\n\r\n> 栈的介绍\r\n\r\n栈是一个**先进后出**的有序序列。\r\n\r\n栈是限制线性表中的数据插入和删除**只能在线性表的同一端进行**的一种特殊线性表。允许插入和删除的一端称为**栈顶**，另一端称为**栈底**。\r\n\r\n\r\n\r\n**栈的应用场景**\r\n\r\n- 子程序的调用，在跳往子程序前，会先将下个指令的地址存到堆栈中，直到子程序执行完后再将地址取出，以回到原来的程序中。\r\n- 处理递归调用：和子程序的调用类似，只是存储下一个命令的地址外，也将参数，区域变量等数据存入堆栈中。\r\n- 表达式的转换[中缀表达式转后缀表达式]\r\n- 二叉树的遍历\r\n- 图形的深度优先搜索\r\n\r\n\r\n\r\n#### 数组模拟栈的思路\r\n\r\n定义一个top来表示栈顶，初始化为-1\r\n\r\n入栈top++；stack[top] = data;\r\n\r\n出栈int value = stack[top];top--;return top;\r\n\r\n\r\n\r\n代码\r\n\r\n```java\r\npackage day5栈;\r\n\r\n/**\r\n * @author zhang\r\n * @date 2020/12/28 21:19\r\n */\r\npublic class ArrayStackDemo {\r\n    public static void main(String[] args) {\r\n        ArrayStack stack = new ArrayStack(5);\r\n        stack.push(1);\r\n        stack.push(2);\r\n        stack.push(3);\r\n        stack.push(4);\r\n        stack.push(5);\r\n        stack.list();\r\n\r\n        stack.pop();\r\n\r\n        stack.list();\r\n    }\r\n}\r\n\r\n\r\n//表示栈结构\r\nclass ArrayStack{\r\n    private int maxSize;//栈的大小\r\n    private int[] stack;//数组模拟栈，放数据\r\n    private int top = -1;//栈顶指针，初始化为-1\r\n\r\n    public ArrayStack(int maxSize){\r\n        this.maxSize = maxSize;\r\n        stack = new int[maxSize];\r\n    }\r\n\r\n    //栈满\r\n    public boolean isFull(){\r\n        return top == maxSize - 1;\r\n    }\r\n\r\n    //栈空\r\n    public boolean isEmpty(){\r\n        return top == -1;\r\n    }\r\n\r\n    //入栈\r\n    public void push(int value){\r\n        //先判断是否栈满\r\n        if (isFull()) {\r\n            throw new RuntimeException(\"栈满\");\r\n        }\r\n        top ++;\r\n        stack[top] = value;\r\n    }\r\n\r\n    //出栈\r\n    public int pop(){\r\n        if (isEmpty()){\r\n            throw new RuntimeException(\"栈空\");\r\n        }\r\n        int temp = stack[top];\r\n        top --;\r\n        return temp;\r\n    }\r\n\r\n    //遍历栈\r\n    public void list(){\r\n        if (isEmpty()){\r\n            throw new RuntimeException(\"栈空\");\r\n        }\r\n\r\n        for (int i = top;i >= 0;i--){\r\n            System.out.printf(\"stack[%d]=%d\\n\",i,stack[i]);\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n\r\n\r\n#### 栈的一个实际需求\r\n\r\n**栈实现综合计算器**\r\n\r\n思路\r\n\r\n1. 通过一个index值(索引)，遍历表达式\r\n2. 如果我们发现是一个数字，就直接入数字栈\r\n3. 如果我们扫描的是一个符号，就分以下两种情况\r\n   1. 如果当前符号栈为空，就直接入栈。\r\n   2. 如果符号栈有操作符，就进行比较，如果当前的操作符优先级小于或者等于栈中的操作符，就需要从栈中pop出两个数，从符号栈中pop出一个符号，进行运算，将得到结果，入数字栈，然后将当前的操作符入符号栈，如果当前的操作符的优先级大于栈中的操作符，就直接入符号栈。\r\n4. 当表达式扫面完毕，就顺序的从数字栈和符号栈中pop出相应的符号和数字，并运行。\r\n5. 最后在数字栈只有一个数字，就是表达式的结果。\r\n\r\n', '2021-03-17 18:16:54', 'https://cdn.jsdelivr.net/gh/zhangliyuangit/img/20210316125858.png', 1, '数据结构是计算机存储、组织数据的方式。数据结构是指相互之间存在一种或多种特定关系的数据元素的集合。通常情况下，精心选择的数据结构可以带来更高的运行或者存储效率。数据结构往往同高效的检索算法和索引技术有关。');
INSERT INTO `s_article` VALUES (8, '注解和反射', '# 注解和反射\r\n\r\n## 注解\r\n\r\n### 什么是注解\r\n\r\njava.Annotation包\r\n\r\n- Annotation是从JDK5.0开始引入的新技术\r\n- Annotation的作用：\r\n  - 不是程序本事，可以对程序做出解释（这一点和注释comment没什么区别）\r\n  - 可以被其他程序（比如编译器）读取\r\n- Annotation的格式\r\n  - 注解是以\"@注释名\"在代码中存在的，还可以添加一些参数值，例如：@SuppressWarnings(value=\"unchecked\")\r\n\r\n- Annotation在哪里使用?\r\n  - 可以附加在package，class，method，filed等上面， 相当于给他们添加了额外的辅助信息，我们可以通过反射机制编程实现对这些元数据的访问\r\n\r\n### 内置注解\r\n\r\n**@Override**：定义在java.lang.Override中，此注解只适合用于修辞方法，表示一个方法声明打算重写超类中的另一个方法声明\r\n**@Deprecated**：定义在java.lang.Deprecated中，此注解可以用于修辞方法，属性，类，表示不鼓励程序员使用这样的元素，通常是因为他们很危险或者存在更好的选择\r\n\r\n**@SuppressWarnings**:定义在java.lang.SuppressWarning中，用来抑制编译时的警告信息。\r\n\r\n### 元注解\r\n\r\n- 元注解的作用就是负责注解其他注解，java定义了4个标准的meta-annotation类型，他们被用来提供给对其他annotation类型做说明\r\n  - **@Target**：用于描述注解的使用范围（即：被描述的注解可以用在什么地方）\r\n  - **@Retention**：表示需要在什么级别保存该注释信息，用于描述注解的生命周期\r\n    - （SOURCE<CLASS<RUNTIME）\r\n  - **@Document**：说明该注解将被包含在javadoc中\r\n  - **Inherited**：说明子类可以继承父类中的该注解\r\n\r\n### 自定义注解\r\n\r\n使用`@interface`自定义注解时，自动继承了java.lang.anntation.Anntation接口\r\n\r\n\r\n\r\n**分析：**\r\n\r\n1. @interface用来声明一个注解，格式：public @interface 注解名 {定义内容}\r\n2. 其中每一个方法实际上是声明了一个配置参数\r\n3. 方法的名称就是参数的名称\r\n4. 返回值的类型就是参数的类型（返回值只能是基本类型，Class，String，enum）\r\n5. 可以通过default来声明参数的默认值\r\n6. 如果只有一个参数成员，一般参数名为value\r\n7. 注解元素必须有值，我们定义注解元素时，经常使用空字符串，0作为默认值\r\n\r\n```java\r\n/**\r\n * @author zhang\r\n * @date 2020/6/10 19:05\r\n */\r\npublic class Demo3 {\r\n    @MyAnnotation2(name = \"张三\",schools = {\"黑龙江八一农垦大学\"})\r\n    public void test(){}\r\n}\r\n\r\n@Target({ElementType.TYPE,ElementType.METHOD})\r\n@Retention(RetentionPolicy.RUNTIME)\r\n@interface MyAnnotation2{\r\n    //注解的参数\r\n    String name() default \"\";\r\n    int age() default 0;\r\n    int id() default 1;\r\n\r\n    String[] schools() default {\"清华大学\"};\r\n}\r\n\r\n```\r\n\r\n\r\n\r\n## 反射\r\n\r\n### 反射概述\r\n\r\n- Reflection(反射)时Java被视为动态语言的关键，反射机制允许程序在执行期借助Reflection API获取任何类的内部信息，并能直接操作任意对象的内部属性及方法\r\n\r\n`Class c = Class.forName(\"java.lang.String\")`\r\n\r\n- 加载完类之后，在堆内存的方法去中就产生了一个class类型的对象(一个类只有一个class对象)，这个对象就包含了完整的类的结构。这个对象就像一面镜子，透过这个镜子看到类的结构，所以，我们形象的称之为：反射\r\n\r\n![](https://cdn.jsdelivr.net/gh/zhangliyuangit/img/20200611083859.png)\r\n\r\n\r\n\r\n> **Java反射的优缺点**\r\n\r\n优点：可以实现动态创建对象和编译，体现出很大的灵活性\r\n\r\n缺点：对性能有影响。使用反射基本上是一种解释操作，我们可以告诉JVM，我们希望做什么兵器它满足我们的需求。这类操作总是慢于直接执行相同的操作。\r\n\r\n\r\n\r\n### 获得反射对象\r\n\r\n**Class类**\r\n\r\n对象照镜子后可以得到的信息：某个类的属性、方法和构造器、某个类到底实现了哪些接口。对于每个类而言，JRE都为其保留了一个不变的Class类型的对象。一个Class对象包含了特定的某个结构(class/interface/enum/annotation/primitive type/void[])的有关信息。\r\n\r\n- Class本身也是一个类\r\n- Class对象只能由系统建立对象\r\n- 一个加载的类在JVM中只会有一个Class实例\r\n- 一个Class对象对应的是一个加载到JVM中的一个.class文件\r\n- 每个类的实例都会记得自己是由哪个Class实例所生成\r\n- 通过Class可以完整地得到一个类中的所有被加载的结构\r\n- Class类是Reflection的根源，支队任何你想动态加载、运行的类，唯有先获得相应的Class对象\r\n\r\n\r\n\r\n**Class的常用方法**\r\n\r\n---\r\n\r\n| 方法名                                  | 功能说明                                                |\r\n| --------------------------------------- | ------------------------------------------------------- |\r\n| static ClassforName(String name)        | 返回指定类名name的Class对象                             |\r\n| Object newInstance()                    | 调用缺省构造函数，返回一个Class对象的实例               |\r\n| getName()                               | 返回此Class对象表示的实体(类、接口、数组类或void)的名称 |\r\n| Class getSuperClass                     | 返回当前Class对象的父类Class对象                        |\r\n| Class[] getinterfaces                   | 返回当前Class对象的接口                                 |\r\n| ClassLoader getClassLoader              | 返回该类的类加载器                                      |\r\n| Constructor[] getConstructors()         | 返回一个包含某些Constructor对象的数组                   |\r\n| Method getMethod(String name,Class.. T) | 返回一个Method对象，此对象的参数类型为paramType         |\r\n| Field[] getDeclaredFields()             | 返回Field对象的一个数组                                 |\r\n\r\n### Java内存分析\r\n\r\n![](https://cdn.jsdelivr.net/gh/zhangliyuangit/img/20200611193710.png)\r\n\r\n**类的加载过程**\r\n\r\n当程序主动使用某个类时，如果该类未被加载到内存中，则系统会通过如下三个步骤来对该类进行初始化。\r\n\r\n![](https://cdn.jsdelivr.net/gh/zhangliyuangit/img/20200611194753.png)\r\n\r\n- **加载**：将class文件字节码内容加载到内存中，并将这些静态数据转换成方法区运行时的数据结构，然后生成一个代表这个类的java.lang.Class对象\r\n- **链接**：将java类的二进制文件合并到JVM的运行状态之中的过程\r\n  - 验证：确保加载的类信息符合JVM规范，没有安全方面的问题\r\n  - 准备：正式为变量(static)分配内存并设置类变量默认初始值的阶段，这些内存都将在方法区中进行分配\r\n  - 解析：虚拟机常量池内的符号引用(常量名)替换为直接引用（地址）的过程\r\n- **初始化**：\r\n  - 执行类构造器`<clinit>()`方法的过程。类构造器`<clinit>()`方法由编译器自动收集类中所有变量的赋值动作和静态代码块中的语句合并产生的。（类构造器时构造类信息的，不是构造该类对象的构造器）\r\n  - 当初始化一个类的时候，如果发现器父类没有进行初始化，则需要先触发器父类的初始化\r\n  - 虚拟机会保证一个类的`<clinit>()`方法在多线程环境中被正确加锁和同步。\r\n\r\n> **什么时候会发生类的初始化？**\r\n\r\n- 类的主动引用（一定会发生类的初始化）\r\n  - 当虚拟机启动时，先初始化main方法所在的类\r\n  - new一个类的对象\r\n  - 调用类的静态成员（除了final常量）和静态方法\r\n  - 使用java.lang.reflect包的方法对类进行反射调用\r\n  - 当初始化一个类，如果其父类没有被初始化，则先会初始化它的父类\r\n- 类的被动引用（不会发生类的初始化）\r\n  - 当访问一个静态域时，只有真正声明这个域的类才会被初始化。如：当通过子类引用父类的静态变量，不会导致子类初始化\r\n  - 通过数组定义类引用，不会触发此类的初始化\r\n  - 引用常量不会触发此类的初始化（常量在链接阶段就已经存入调用类的常量池了）\r\n\r\n### 类加载器\r\n\r\n**类加载器的作用**：将class文件的字节码内容加载到内存中，并将这些静态数据转换成方法区的运行时数据结构，然后在堆中生成一个代表这个类的java.lang.Class对象，作为方法区中类数据的访问入口，\r\n\r\n**类缓存**：标准的javaSE类可以按照要求查找类，但一旦某个类被加载到类加载器中，它将维持加载（缓存）一段时间。不过JVM垃圾回收机制可以回收这些Class对象\r\n\r\n### 获取运行时类的完整结构\r\n\r\n通过反射获取运行时类的完整结构\r\n\r\nField、Method、Constructor、Superclass、Interface、Annotation\r\n\r\n- 实现类的全部接口\r\n- 所继承的父类\r\n- 全部的构造器\r\n- 全部的方法\r\n- 全部的Field\r\n- 注解\r\n- 。。。\r\n\r\n```java\r\npackage reflect;\r\n\r\nimport java.lang.reflect.Constructor;\r\nimport java.lang.reflect.Field;\r\nimport java.lang.reflect.Method;\r\n\r\n/**\r\n * @author zhang\r\n * @date 2020/6/12 15:59\r\n */\r\npublic class Demo6 {\r\n    public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException {\r\n        Class<?> c1 = Class.forName(\"reflect.User\");\r\n        //获得类的名字\r\n        System.out.println(c1.getName());\r\n        System.out.println(c1.getSimpleName());\r\n\r\n        //获得类的属性\r\n        Field[] fields = c1.getFields();//只能获得public修饰的\r\n        for (Field field : fields) {\r\n            System.out.println(field);\r\n        }\r\n\r\n        Field[] fields1 = c1.getDeclaredFields();\r\n        for (Field field : fields1) {\r\n            System.out.println(field);\r\n        }\r\n\r\n        //获得类的方法\r\n        Method[] methods = c1.getMethods();//获得本类机器父类的全部public方法\r\n        for (Method method : methods) {\r\n            System.out.println(method);\r\n        }\r\n\r\n        //获得构造器\r\n        Constructor<?>[] constructors = c1.getConstructors();\r\n        for (Constructor<?> constructor : constructors) {\r\n            System.out.println(constructor);\r\n        }\r\n\r\n        //获得指定的构造器\r\n        Constructor<?> constructor = c1.getConstructor(String.class,int.class,int.class);\r\n        System.out.println(constructor);\r\n    }\r\n}\r\n\r\n```\r\n\r\n### 有了class对象，能做什么？\r\n\r\n创建类的对象：调用Class对象的newInstance()方法\r\n\r\n- 类必须有一个无参数的构造器\r\n- 类的构造器的访问权限需要足够\r\n\r\n**调用指定的方法**\r\n\r\n通过反射，调用类中的方法，通过Method类完成。\r\n\r\n1. 通过Class类的getMethod(String name,Class..parameterTypes)方法取得一个Method对象，并设置此方法操作是锁需要的参数类型\r\n2. 之后使用Object invoke(Object obj,Object[] args)进行调用，并向方法中传递要设置的obj对象的参数信息。\r\n\r\n![](https://cdn.jsdelivr.net/gh/zhangliyuangit/img/20200612164612.png)\r\n\r\n`Object invoke(Object obj,Object...args)`\r\n\r\n- Object对应原方法的返回值，若方法无返回值，此时返回null\r\n- 若原方法为静态方法，此时形参Object obj可为null\r\n- 若原方法参数列表为空，则Object[] args为null\r\n- 若原方法声明为private，则需要在调用此invoke()方法前，显式调用方法对象的setAccessible(true)方法，将可访问private的方法。', '2021-03-14 21:07:09', 'https://cdn.jsdelivr.net/gh/zhangliyuangit/img/20210316130417.png', 1, 'Java 语言中的类、方法、变量、参数和包等都可以被标注。和 Javadoc 不同，Java 标注可以通过反射获取标注内容。在编译器生成类文件时，标注可以被嵌入到字节码中。Java 虚拟机可以保留标注内容，在运行时可以获取到标注内容 。 当然它也支持自定义 Java 标注。');
INSERT INTO `s_article` VALUES (9, 'Dubbo', '---\ntitle: Dubbo和Zookeeper集成\ndate: 2020-10-24 11:01:19\ntags:\n	- Java\n	- SpringBoot\n\n---\n\n> 分布式服务架构\n\n当垂直应用越来越多，应用之间交互不可避免，将核心业务抽取出来，作为独立的服务，逐渐形成稳定的服务中心，使前端应用能更快速的响应多变的市场需求。此时，用于提高业务复用及整合的**分布式服务框架(RPC)**是关键。\n\n<!-- more -->\n\n### 什么是RPC框架\n\nRPC【Remote Procedure Call】是指远程过程调用，是一种进程间通信方式，他是一种技术的思想，而不是规范。它允许程序调用另一个地址空间（通常是共享网络的另一台机器上）的过程或函数，而不用程序员显式编码这个远程调用的细节。即程序员无论是调用本地的还是远程的函数，本质上编写的调用代码基本相同。\n\n也就是说两台服务器A，B，一个应用部署在A服务器上，想要调用B服务器上应用提供的函数/方法，由于不在一个内存空间，不能直接调用，需要通过网络来表达调用的语义和传达调用的数据。为什么要用RPC呢？就是无法在一个进程内，甚至一个计算机内通过本地调用的方式完成的需求，比如不同的系统间的通讯，甚至不同的组织间的通讯，由于计算能力需要横向扩展，需要在多台机器组成的集群上部署应用。RPC就是要像调用本地的函数一样去调远程函数；\n\n\n\n### dubbo基本概念\n\n![](https://cdn.jsdelivr.net/gh/zhangliyuangit/img/20201024110802.png)\n\n\n\n**服务提供者(Provider):**暴露服务的服务提供发，服务提供者启动时，向注册中心注册自己提供的服务\n\n**服务消费者(Consumer)**:调用远程服务的服务消费方，服务消费者在启动时，向注册中心订阅自己锁需要的服务，服务消费者从提供者列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选用另一台\n\n**注册中心(Register):**注册中心返回服务提供者地址列表给服务消费者，如果有变更，注册中心将基于长连接推送变更数据给数据消费者\n\n**监控中心(Moiter):**服务消费者和提供者，在内存累计调用次数和调用时间，定义每分钟发送一次统计数据到监控中心\n\n\n\n### 使用Dubbo-admin\n\ndubbo本身并不是一个服务软件。它其实就是一个jar包，能够帮你的java程序连接到zookeeper，并利用zookeeper消费、提供服务。\n\n但是为了让用户更好的管理监控众多的dubbo服务，官方提供了一个可视化的监控程序dubbo-admin，不过这个监控即使不装也不影响使用。\n\n地址 ：https://github.com/apache/dubbo-admin/tree/master\n\n下载完成后解压,修改dubbo-admin-server下的配置文件，修改成我们自己的配置即可\n\n![](https://cdn.jsdelivr.net/gh/zhangliyuangit/img/20201024145251.png)\n\n将这个项目达成jar包\n\n`mvn clean package -Dmaven.test.skip=true`\n\n![](https://cdn.jsdelivr.net/gh/zhangliyuangit/img/20201024150033.png)\n\n用java -jar启动就好了\n\n访问localhost:8080\n\n### 测试环境搭建\n\n#### Linux安装zookeeper\n\n- xftp上传zookeeper到根目录\n\n![](https://cdn.jsdelivr.net/gh/zhangliyuangit/img/20201024113336.png)\n\n- 解压zookeeper到指定目录\n\n`tar -zxvf zookeeper-3.4.6.tar.gz -C /usr/local/`\n\n- 进入zookeeper目录\n\n`cd zookeeper-3.4.6`\n\n- 创建data目录\n\n`mkdir data`\n\n- 进入conf目录\n\n`cd conf`\n\n- 重命名/拷贝zoo_sample.cfg,修改为zoo.cfg\n\n`mv zoo_sample.cfg zoo.cfg`\n\n- vim进入zoo.cfg文件\n\n`vim zoo.cfg`\n\n- 修改zoo.cfg文件\n\n修改datadir=/usr/local/zookeeper-3.4.6/data\n注意:使用i进入修改模式,修改后使用esc退出修改,输入:wq退出vim\n\n![](https://cdn.jsdelivr.net/gh/zhangliyuangit/img/20201024113850.png)\n\n#### 操作zookeeper\n\n1.**启动**\n进入bin目录下,执行\n`./zkServer.sh start`\n\n2.**停止**\n`./zkServer.sh stop`\n\n3.**查看状态**\n`./zkServer.sh status`\n\n### SpringBoot+dubbo+zookeeper\n\n\n\n#### 编写服务提供者\n\n> 导入依赖\n\n```xml\n<!--dubbo-->\n<!-- Dubbo Spring Boot Starter -->\n<dependency>\n   <groupId>org.apache.dubbo</groupId>\n   <artifactId>dubbo-spring-boot-starter</artifactId>\n   <version>2.7.3</version>\n</dependency>\n<!--zookeeper-->\n<!-- https://mvnrepository.com/artifact/com.github.sgroschupf/zkclient -->\n<dependency>\n   <groupId>com.github.sgroschupf</groupId>\n   <artifactId>zkclient</artifactId>\n   <version>0.1</version>\n</dependency>\n<!-- 引入zookeeper -->\n<dependency>\n   <groupId>org.apache.curator</groupId>\n   <artifactId>curator-framework</artifactId>\n   <version>2.12.0</version>\n</dependency>\n<dependency>\n   <groupId>org.apache.curator</groupId>\n   <artifactId>curator-recipes</artifactId>\n   <version>2.12.0</version>\n</dependency>\n<dependency>\n   <groupId>org.apache.zookeeper</groupId>\n   <artifactId>zookeeper</artifactId>\n   <version>3.4.14</version>\n   <!--排除这个slf4j-log4j12-->\n   <exclusions>\n       <exclusion>\n           <groupId>org.slf4j</groupId>\n           <artifactId>slf4j-log4j12</artifactId>\n       </exclusion>\n   </exclusions>\n</dependency>\n```\n\n> 编写service接口\n\n```java\npackage com.gem.service;\n/**\n * @author zhang\n * @date 2020/10/24 13:43\n */\npublic interface HelloService {\n    String sayHello(String name);\n}\n```\n\n> 编写实现类\n\n这里注意@Service注解使用的是dubbo的而非spring提供的，loadbalance表示负载均衡，interfaceClass指定接口\n\n```java\npackage com.gem.service.impl;\n\nimport com.gem.service.HelloService;\nimport org.apache.dubbo.config.annotation.Service;\n\n/**\n * @author zhang\n * @date 2020/10/24 13:50\n */\n@Service(loadbalance = \"random\",interfaceClass = HelloService.class)\npublic class HelloServiceImpl implements HelloService {\n    @Override\n    public String sayHello(String name) {\n        return \"Hello,\" + name;\n    }\n}\n```\n\n> 配置文件\n\n```properties\n#当前应用名称\ndubbo.application.name=dubbo-prodiver\n#注册中心地址\ndubbo.registry.address=zookeeper://192.168.40.130:2181\n#扫描指定包下的服务\ndubbo.scan.base-packages=com.gem.service\n#服务器端口\nserver.port=9999\n```\n\n#### 编写服务消费者\n\n> 导入依赖\n\n同上\n\n> 编写service接口\n\n同上\n\n> 配置文件\n\n```yaml\n#当前应用名称\ndubbo:\n  application:\n    name: dubbo-consumer\n  registry:\n    address: zookeeper://192.168.40.130:2181\n  scan:\n    base-packages: com.gem.controller\n\n\nserver:\n  port: 8888\n```\n\n> 编写Controller\n\n我们要使用服务提供者的服务，使用@Reference注解去注册中心查找服务\n\n```java\npackage com.gem.controller;\n\nimport com.gem.service.HelloService;\nimport org.apache.dubbo.config.annotation.Reference;\nimport org.springframework.stereotype.Controller;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.ResponseBody;\n\n/**\n * @author zhang\n * @date 2020/10/24 13:58\n */\n@Controller\npublic class HelloController {\n    //到注册中心查找服务\n    @Reference(check = false,loadbalance = \"random\")\n    HelloService helloService;\n\n    @RequestMapping(\"/hello\")\n    @ResponseBody\n    public String sayHello(String name){\n        return helloService.sayHello(name);\n    }\n}\n```\n\n#### 测试\n\n启动服务器，访问呢服务消费者的controller\n\n![](https://cdn.jsdelivr.net/gh/zhangliyuangit/img/20201024141943.png)', '2021-03-03 21:08:35', 'https://cdn.jsdelivr.net/gh/zhangliyuangit/img/20210316130417.png', 1, 'Dubbo(读音[ˈdʌbəʊ])是阿里巴巴公司开源的一个高性能优秀的服务框架，使得应用可通过高性能的 RPC 实现服务的输出和输入功能，可以和 Spring框架无缝集成。Dubbo是一款高性能、轻量级的开源Java RPC框架，它提供了三大核心能力：面向接口的远程方法调用，');
INSERT INTO `s_article` VALUES (10, '单例模式', '单例模式\n\n<!-- more -->\n\n### 概述\n\n单例模式的**定义**就是**确保某一个类只有一个实例，并且提供一个全局访问点。**属于设计模式三大类中的**`创建型模式`**。\n单例模式具有典型的三个**特点**：\n\n- 只有一个实例。\n- 自我实例化。\n- 提供全局访问点。\n\n其**UML**结构图非常简单，就只有一个类，如下图：\n\n![](https://cdn.jsdelivr.net/gh/zhangliyuangit/img/20200723175531.png)\n\n### 优缺点\n\n- **优点**：由于单例模式只生成一个实例，所以能够节省系统资源，减少性能开销，提高系统效率，同时也能够严格的控制客户对他的访问。\n- **缺点**：也正是因为系统只有一个实例，这样就导致了单例类的职责过重，违背了“单一职责”的原则，同时也没有抽象类，这样扩展起来有一定的困难。\n\n### 实现方式\n\n- **饿汉式：线程安全**，调用效率高，但是不能延迟加载。\n\n```java\npackage class类;\n\n/**\n * @author zhang\n * @date 2020/7/23 18:02\n */\npublic class SingletonDemo1 {\n    //线程安全，类初始化立即加载这个对象\n    private static SingletonDemo1 singletonDemo1 = new SingletonDemo1();\n\n    //私有构造方法-->外界不能通过new来创建对象\n    private SingletonDemo1(){}\n\n    //提供一个公开的静态方法来创建当前类的对象\n    public static SingletonDemo1 getInstance(){\n        return singletonDemo1;\n    }\n}\n\n```\n\n![](https://cdn.jsdelivr.net/gh/zhangliyuangit/img/20200723181255.png)\n\n由于该模式类加载的时候对象就已创建了，所以加载类的速度比较慢，但是获取对象的速度比较块，且是**线程安全**\n\n的。\n\n- **懒汉式：线程不安全**\n\n```java\npackage class类;\n\nimport javax.crypto.spec.PSource;\n\n/**\n * @author zhang\n * @date 2020/7/23 18:09\n */\npublic class SingletonDemo2 {\n    private static SingletonDemo2 singletonDemo2;\n\n    //提供私有的构造方法\n    private SingletonDemo2(){}\n\n    public static SingletonDemo2 getInstance(){\n        if (singletonDemo2 == null){\n            singletonDemo2 = new SingletonDemo2();\n        }\n        return singletonDemo2;\n    }\n}\n```\n\n由于该模式是在运行时加载对象的，所以加载类比较快，但是对象的获取速度相对较慢，且**线程不安全**。**如果想要线程安全的话可以加上`synchronized`关键字**，但是这样会付出惨重的效率代价\n\n- **懒汉式(双重同步锁)**\n\n```java\npackage class类;\n\n/**\n * @author zhang\n * @date 2020/7/23 18:19\n */\npublic class SingletonDemo3 {\n    //使用双重锁机制\n    private static volatile SingletonDemo3 singletonDemo3;\n\n    //提供私有的构造方法\n    private SingletonDemo3(){}\n\n    public static SingletonDemo3 getInstance(){\n        if (singletonDemo3 == null){\n            //线程同步加锁\n            synchronized (SingletonDemo3.class){\n                if (singletonDemo3 == null){\n                    singletonDemo3 = new SingletonDemo3();\n                }\n            }\n        }\n        return singletonDemo3;\n    }\n}\n```\n\n优点：线程安全，缺点：每次获取实例都要加锁，耗费资源，其实只要实例已经生成，以后获取就不需要再锁了\n\n\n\n### 常见应用场景\n\n1. 网站计数器。\n2. 项目中用于读取配置文件的类。\n3. 数据库连接池。因为数据库连接池是一种数据库资源。\n4. Spring中，每个`Bean`默认都是单例的，这样便于Spring容器进行管理。\n5. Servlet中`Application`\n6. Windows中任务管理器，回收站。\n   等等。\n\n', '2021-03-30 21:09:35', 'https://cdn.jsdelivr.net/gh/zhangliyuangit/img/20210316130417.png', 1, '单例模式，属于创建类型的一种常用的软件设计模式。通过单例模式的方法创建的类在当前进程中只有一个实例（根据需要，也有可能一个线程中属于单例，如：仅线程上下文内使用同一个实例）');
INSERT INTO `s_article` VALUES (11, 'JWT实战', '# JWT 实战教程\n\n![image-20200726102546868](https://cdn.jsdelivr.net/gh/zhangliyuangit/img/image-20200726102546868.png)\n\n## 1.什么是JWT\n\nJSON Web Token (JWT) is an open standard ([RFC 7519](https://tools.ietf.org/html/rfc7519)) that defines a compact and self-contained way for securely transmitting information between parties as a JSON object. This information can be verified and trusted because it is digitally signed. JWTs can be signed using a secret (with the **HMAC** algorithm) or a public/private key pair using **RSA** or **ECDSA**.\n\n​																																																											---[摘自官网]\n\n```markdown\n# 1.翻译\n-  官网地址: https://jwt.io/introduction/\n-  翻译: jsonwebtoken（JWT）是一个开放标准（rfc7519），它定义了一种紧凑的、自包含的方式，用于在各方之间以JSON对象安全地传输信息。此信息可以验证和信任，因为它是数字签名的。jwt可以使用秘密（使用HMAC算法）或使用RSA或ECDSA的公钥/私钥对进行签名\n\n# 2.通俗解释\n- JWT简称JSON Web Token,也就是通过JSON形式作为Web应用中的令牌,用于在各方之间安全地将信息作为JSON对象传输。在数据传输过程中还可以完成数据加密、签名等相关处理。\n```\n\n## 2.JWT能做什么\n\n```markdown\n# 1.授权\n- 这是使用JWT的最常见方案。一旦用户登录，每个后续请求将包括JWT，从而允许用户访问该令牌允许的路由，服务和资源。单点登录是当今广泛使用JWT的一项功能，因为它的开销很小并且可以在不同的域中轻松使用。\n\n# 2.信息交换\n- JSON Web Token是在各方之间安全地传输信息的好方法。因为可以对JWT进行签名（例如，使用公钥/私钥对），所以您可以确保发件人是他们所说的人。此外，由于签名是使用标头和有效负载计算的，因此您还可以验证内容是否遭到篡改。\n```\n\n## 3.为什么是JWT\n\n### 基于传统的Session认证\n\n```markdown\n# 1.认证方式\n- 我们知道，http协议本身是一种无状态的协议，而这就意味着如果用户向我们的应用提供了用户名和密码来进行用户认证，那么下一次请求时，用户还要再一次进行用户认证才行，因为根据http协议，我们并不能知道是哪个用户发出的请求，所以为了让我们的应用能识别是哪个用户发出的请求，我们只能在服务器存储一份用户登录的信息，这份登录信息会在响应时传递给浏览器，告诉其保存为cookie,以便下次请求时发送给我们的应用，这样我们的应用就能识别请求来自哪个用户了,这就是传统的基于session认证。\nt\n# 2.认证流程\n```\n\n![image-20200726103959013](https://cdn.jsdelivr.net/gh/zhangliyuangit/img/image-20200726103959013.png)\n\n```markdown\n# 3.暴露问题\n- 1.每个用户经过我们的应用认证之后，我们的应用都要在服务端做一次记录，以方便用户下次请求的鉴别，通常而言session都是保存在内存中，而随着认证用户的增多，服务端的开销会明显增大\n\n- 2.用户认证之后，服务端做认证记录，如果认证的记录被保存在内存中的话，这意味着用户下次请求还必须要请求在这台服务器上,这样才能拿到授权的资源，这样在分布式的应用上，相应的限制了负载均衡器的能力。这也意味着限制了应用的扩展能力。\n\n- 3.因为是基于cookie来进行用户识别的, cookie如果被截获，用户就会很容易受到跨站请求伪造的攻击。\n\n- 4.在前后端分离系统中就更加痛苦:如下图所示\n	也就是说前后端分离在应用解耦后增加了部署的复杂性。通常用户一次请求就要转发多次。如果用session 每次携带sessionid 到服务	器，服务器还要查询用户信息。同时如果用户很多。这些信息存储在服务器内存中，给服务器增加负担。还有就是CSRF（跨站伪造请求攻击）攻击，session是基于cookie进行用户识别的, cookie如果被截获，用户就会很容易受到跨站请求伪造的攻击。还有就是	     sessionid就是一个特征值，表达的信息不够丰富。不容易扩展。而且如果你后端应用是多节点部署。那么就需要实现session共享机制。	不方便集群应用。\n```\n\n![image-20200804212240422](https://cdn.jsdelivr.net/gh/zhangliyuangit/img/image-20200804212240422.png)\n\n### 基于JWT认证\n\n![image-20200726183248298](https://cdn.jsdelivr.net/gh/zhangliyuangit/img/image-20200726183248298.png)\n\n```markdown\n# 1.认证流程\n- 首先，前端通过Web表单将自己的用户名和密码发送到后端的接口。这一过程一般是一个HTTP POST请求。建议的方式是通过SSL加密的传输（https协议），从而避免敏感信息被嗅探。\n- 后端核对用户名和密码成功后，将用户的id等其他信息作为JWT Payload（负载），将其与头部分别进行Base64编码拼接后签名，形成一个JWT(Token)。形成的JWT就是一个形同lll.zzz.xxx的字符串。 token head.payload.singurater\n\n- 后端将JWT字符串作为登录成功的返回结果返回给前端。前端可以将返回的结果保存在localStorage或sessionStorage上，退出登录时前端删除保存的JWT即可。\n\n- 前端在每次请求时将JWT放入HTTP Header中的Authorization位。(解决XSS和XSRF问题) HEADER\n\n- 后端检查是否存在，如存在验证JWT的有效性。例如，检查签名是否正确；检查Token是否过期；检查Token的接收方是否是自己（可选）。\n- 验证通过后后端使用JWT中包含的用户信息进行其他逻辑操作，返回相应结果。\n\n# 2.jwt优势\n\n- 简洁(Compact): 可以通过URL，POST参数或者在HTTP header发送，因为数据量小，传输速度也很快\n\n- 自包含(Self-contained)：负载中包含了所有用户所需要的信息，避免了多次查询数据库\n\n- 因为Token是以JSON加密的形式保存在客户端的，所以JWT是跨语言的，原则上任何web形式都支持。\n\n- 不需要在服务端保存会话信息，特别适用于分布式微服务。\n```\n\n## 4.JWT的结构是什么?\n\n```markdown\ntoken   string  ====>  header.payload.singnature   token   \n\n# 1.令牌组成\n- 1.标头(Header)\n- 2.有效载荷(Payload)\n- 3.签名(Signature)\n- 因此，JWT通常如下所示:xxxxx.yyyyy.zzzzz   Header.Payload.Signature\n```\n\n```markdown\n# 2.Header\n- 标头通常由两部分组成：令牌的类型（即JWT）和所使用的签名算法，例如HMAC SHA256或RSA。它会使用 Base64 编码组成 JWT 结构的第一部分。\n\n- 注意:Base64是一种编码，也就是说，它是可以被翻译回原来的样子来的。它并不是一种加密过程。\n```\n\n```json\n{\n  \"alg\": \"HS256\",\n  \"typ\": \"JWT\"\n}\n```\n\n```markdown\n# 3.Payload\n- 令牌的第二部分是有效负载，其中包含声明。声明是有关实体（通常是用户）和其他数据的声明。同样的，它会使用 Base64 编码组成 JWT 结构的第二部分\n```\n\n```json\n{\n  \"sub\": \"1234567890\",\n  \"name\": \"John Doe\",\n  \"admin\": true\n}\n```\n\n```markdown\n# 4.Signature\n- 前面两部分都是使用 Base64 进行编码的，即前端可以解开知道里面的信息。Signature 需要使用编码后的 header 和 payload 以及我们提供的一个密钥，然后使用 header 中指定的签名算法（HS256）进行签名。签名的作用是保证 JWT 没有被篡改过\n- 如:\n	HMACSHA256(base64UrlEncode(header) + \".\" + base64UrlEncode(payload),secret);\n\n# 签名目的\n- 最后一步签名的过程，实际上是对头部以及负载内容进行签名，防止内容被窜改。如果有人对头部以及负载的内容解码之后进行修改，再进行编码，最后加上之前的签名组合形成新的JWT的话，那么服务器端会判断出新的头部和负载形成的签名和JWT附带上的签名是不一样的。如果要对新的头部和负载进行签名，在不知道服务器加密时用的密钥的话，得出来的签名也是不一样的。\n\n# 信息安全问题\n- 在这里大家一定会问一个问题：Base64是一种编码，是可逆的，那么我的信息不就被暴露了吗？\n\n- 是的。所以，在JWT中，不应该在负载里面加入任何敏感的数据。在上面的例子中，我们传输的是用户的User ID。这个值实际上不是什么敏	感内容，一般情况下被知道也是安全的。但是像密码这样的内容就不能被放在JWT中了。如果将用户的密码放在了JWT中，那么怀有恶意的第	三方通过Base64解码就能很快地知道你的密码了。因此JWT适合用于向Web应用传递一些非敏感信息。JWT还经常用于设计用户认证和授权系	统，甚至实现Web应用的单点登录。\n```\n\n![image-20200726181136113](https://cdn.jsdelivr.net/gh/zhangliyuangit/img/image-20200726181136113.png)\n\n```markdown\n# 5.放在一起\n- 输出是三个由点分隔的Base64-URL字符串，可以在HTML和HTTP环境中轻松传递这些字符串，与基于XML的标准（例如SAML）相比，它更紧凑。\n- 简洁(Compact)\n	可以通过URL, POST 参数或者在 HTTP header 发送，因为数据量小，传输速度快\n- 自包含(Self-contained)\n	负载中包含了所有用户所需要的信息，避免了多次查询数据库\n```\n\n![image-20200726124257203](https://cdn.jsdelivr.net/gh/zhangliyuangit/img/image-20200726124257203.png)\n\n## 5.使用JWT\n\n```markdown\n# 1.引入依赖\n```\n\n```xml\n<!--引入jwt-->\n<dependency>\n  <groupId>com.auth0</groupId>\n  <artifactId>java-jwt</artifactId>\n  <version>3.4.0</version>\n</dependency>\n```\n\n```markdown\n# 2.生成token\n```\n\n```java\nCalendar instance = Calendar.getInstance();\ninstance.add(Calendar.SECOND, 90);\n//生成令牌\nString token = JWT.create()\n  .withClaim(\"username\", \"张三\")//设置自定义用户名\n  .withExpiresAt(instance.getTime())//设置过期时间\n  .sign(Algorithm.HMAC256(\"token!Q2W#E$RW\"));//设置签名 保密 复杂\n//输出令牌\nSystem.out.println(token);\n```\n\n```markdown\n- 生成结果\neyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJhdWQiOlsicGhvbmUiLCIxNDMyMzIzNDEzNCJdLCJleHAiOjE1OTU3Mzk0NDIsInVzZXJuYW1lIjoi5byg5LiJIn0.aHmE3RNqvAjFr_dvyn_sD2VJ46P7EGiS5OBMO_TI5jg\n```\n\n```markdown\n# 3.根据令牌和签名解析数据\n```\n\n```java\nJWTVerifier jwtVerifier = JWT.require(Algorithm.HMAC256(\"token!Q2W#E$RW\")).build();\nDecodedJWT decodedJWT = jwtVerifier.verify(token);\nSystem.out.println(\"用户名: \" + decodedJWT.getClaim(\"username\").asString());\nSystem.out.println(\"过期时间: \"+decodedJWT.getExpiresAt());\n```\n\n````markdown\n# 4.常见异常信息\n- SignatureVerificationException:				签名不一致异常\n- TokenExpiredException:    						令牌过期异常\n- AlgorithmMismatchException:						算法不匹配异常\n- InvalidClaimException:								失效的payload异常\n````\n\n![image-20200805184517282](https://cdn.jsdelivr.net/gh/zhangliyuangit/img/image-20200805184517282.png)\n\n## 6.封装工具类\n\n```java\npublic class JWTUtils {\n    private static String TOKEN = \"token!Q@W3e4r\";\n    /**\n     * 生成token\n     * @param map  //传入payload\n     * @return 返回token\n     */\n    public static String getToken(Map<String,String> map){\n        JWTCreator.Builder builder = JWT.create();\n        map.forEach((k,v)->{\n            builder.withClaim(k,v);\n        });\n        Calendar instance = Calendar.getInstance();\n        instance.add(Calendar.SECOND,7);\n        builder.withExpiresAt(instance.getTime());\n        return builder.sign(Algorithm.HMAC256(TOKEN)).toString();\n    }\n    /**\n     * 验证token\n     * @param token\n     * @return\n     */\n    public static void verify(String token){\n        JWT.require(Algorithm.HMAC256(TOKEN)).build().verify(token);\n    }\n    /**\n     * 获取token中payload\n     * @param token\n     * @return\n     */\n    public static DecodedJWT getToken(String token){\n        return JWT.require(Algorithm.HMAC256(TOKEN)).build().verify(token);\n    }\n}\n```\n\n## 7.整合springboot\n\n```markdown\n# 0.搭建springboot+mybatis+jwt环境\n- 引入依赖\n- 编写配置\n```\n\n```xml\n<!--引入jwt-->\n<dependency>\n  <groupId>com.auth0</groupId>\n  <artifactId>java-jwt</artifactId>\n  <version>3.4.0</version>\n</dependency>\n\n<!--引入mybatis-->\n<dependency>\n  <groupId>org.mybatis.spring.boot</groupId>\n  <artifactId>mybatis-spring-boot-starter</artifactId>\n  <version>2.1.3</version>\n</dependency>\n\n<!--引入lombok-->\n<dependency>\n  <groupId>org.projectlombok</groupId>\n  <artifactId>lombok</artifactId>\n  <version>1.18.12</version>\n</dependency>\n\n<!--引入druid-->\n<dependency>\n  <groupId>com.alibaba</groupId>\n  <artifactId>druid</artifactId>\n  <version>1.1.19</version>\n</dependency>\n\n<!--引入mysql-->\n<dependency>\n  <groupId>mysql</groupId>\n  <artifactId>mysql-connector-java</artifactId>\n  <version>5.1.38</version>\n</dependency>\n```\n\n```properties\nserver.port=8989\nspring.application.name=jwt\n\nspring.datasource.type=com.alibaba.druid.pool.DruidDataSource\nspring.datasource.driver-class-name=com.mysql.jdbc.Driver\nspring.datasource.url=jdbc:mysql://localhost:3306/jwt?characterEncoding=UTF-8\nspring.datasource.username=root\nspring.datasource.password=root\n\nmybatis.type-aliases-package=com.baizhi.entity\nmybatis.mapper-locations=classpath:com/baizhi/mapper/*.xml\n\nlogging.level.com.baizhi.dao=debug\n```\n\n```markdown\n# 1.开发数据库\n- 这里采用最简单的表结构验证JWT使用\n```\n\n![image-20200805212226422](https://cdn.jsdelivr.net/gh/zhangliyuangit/img/image-20200805212226422.png)\n\n```sql\nDROP TABLE IF EXISTS `user`;\nCREATE TABLE `user` (\n  `id` int(11) NOT NULL AUTO_INCREMENT COMMENT \'主键\',\n  `name` varchar(80) DEFAULT NULL COMMENT \'用户名\',\n  `password` varchar(40) DEFAULT NULL COMMENT \'用户密码\',\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8;\n```\n\n```markdown\n# 2.开发entity\n```\n\n```java\n@Data\n@Accessors(chain=true)\npublic class User {\n    private String id;\n    private String name;\n    private String password;\n}\n```\n\n![image-20200805213539471](JWT 实战教程.assets/image-20200805213539471.png)\n\n```markdown\n# 3.开发DAO接口和mapper.xml\n```\n\n```java\n@Mapper\npublic interface UserDAO {\n    User login(User user);\n}\n```\n\n![image-20200805213603655](https://cdn.jsdelivr.net/gh/zhangliyuangit/img/image-20200805213603655.png)\n\n```xml\n<mapper namespace=\"com.baizhi.dao.UserDAO\">\n    <!--这里就写的简单点了毕竟不是重点-->\n    <select id=\"login\" parameterType=\"User\" resultType=\"User\">\n        select * from user where name=#{name} and password = #{password}\n    </select>\n</mapper>\n```\n\n![image-20200805213628252](https://cdn.jsdelivr.net/gh/zhangliyuangit/img/image-20200805213628252.png)\n\n```markdown\n# 4.开发Service 接口以及实现类\n```\n\n```java\npublic interface UserService {\n    User login(User user);//登录接口\n}\n```\n\n![image-20200805213648147](https://cdn.jsdelivr.net/gh/zhangliyuangit/img/image-20200805213648147.png)\n\n````java\n@Service\n@Transactional\npublic class UserServiceImpl implements UserService {\n    @Autowired\n    private UserDAO userDAO;\n    @Override\n    @Transactional(propagation = Propagation.SUPPORTS)\n    public User login(User user) {\n        User userDB = userDAO.login(user);\n        if(userDB!=null){\n            return userDB;\n        }\n        throw  new RuntimeException(\"登录失败~~\");\n    }\n}\n````\n\n![image-20200805213704965](https://cdn.jsdelivr.net/gh/zhangliyuangit/img/image-20200805213704965.png)\n\n```markdown\n# 5.开发controller\n```\n\n```java\n@RestController\n@Slf4j\npublic class UserController {\n    @Autowired\n    private UserService userService;\n    @GetMapping(\"/user/login\")\n    public Map<String,Object> login(User user) {\n        Map<String,Object> result = new HashMap<>();\n        log.info(\"用户名: [{}]\", user.getName());\n        log.info(\"密码: [{}]\", user.getPassword());\n        try {\n            User userDB = userService.login(user);\n            Map<String, String> map = new HashMap<>();//用来存放payload\n            map.put(\"id\",userDB.getId());\n            map.put(\"username\", userDB.getName());\n            String token = JWTUtils.getToken(map);\n            result.put(\"state\",true);\n            result.put(\"msg\",\"登录成功!!!\");\n            result.put(\"token\",token); //成功返回token信息\n        } catch (Exception e) {\n            e.printStackTrace();\n            result.put(\"state\",\"false\");\n            result.put(\"msg\",e.getMessage());\n        }\n        return result;\n    }\n}\n```\n\n![image-20200805214235426](https://cdn.jsdelivr.net/gh/zhangliyuangit/img/image-20200805214235426.png)\n\n```markdown\n# 6.数据库添加测试数据启动项目\n```\n\n![image-20200805214324868](https://cdn.jsdelivr.net/gh/zhangliyuangit/img/image-20200805214324868.png)\n\n![image-20200805214424786](https://cdn.jsdelivr.net/gh/zhangliyuangit/img/image-20200805214424786.png)\n\n```markdown\n# 7.通过postman模拟登录失败\n```\n\n![image-20200805214610668](https://cdn.jsdelivr.net/gh/zhangliyuangit/img/image-20200805214610668.png)\n\n```markdown\n# 8.通过postman模拟登录成功\n```\n\n![image-20200805214749469](https://cdn.jsdelivr.net/gh/zhangliyuangit/img/image-20200805214749469.png)\n\n```markdown\n# 9.编写测试接口\n```\n\n```java\n@PostMapping(\"/test/test\")\npublic Map<String, Object> test(String token) {\n  Map<String, Object> map = new HashMap<>();\n  try {\n    JWTUtils.verify(token);\n    map.put(\"msg\", \"验证通过~~~\");\n    map.put(\"state\", true);\n  } catch (TokenExpiredException e) {\n    map.put(\"state\", false);\n    map.put(\"msg\", \"Token已经过期!!!\");\n  } catch (SignatureVerificationException e){\n    map.put(\"state\", false);\n    map.put(\"msg\", \"签名错误!!!\");\n  } catch (AlgorithmMismatchException e){\n    map.put(\"state\", false);\n    map.put(\"msg\", \"加密算法不匹配!!!\");\n  } catch (Exception e) {\n    e.printStackTrace();\n    map.put(\"state\", false);\n    map.put(\"msg\", \"无效token~~\");\n  }\n  return map;\n}\n```\n\n![image-20200805215119590](https://cdn.jsdelivr.net/gh/zhangliyuangit/img/image-20200805215119590.png)\n\n```markdown\n# 10.通过postman请求接口\n```\n\n![image-20200805215337303](https://cdn.jsdelivr.net/gh/zhangliyuangit/img/image-20200805215337303.png)\n\n![image-20200805215451442](https://cdn.jsdelivr.net/gh/zhangliyuangit/img/image-20200805215451442.png)\n\n```markdown\n# 11.问题?\n- 使用上述方式每次都要传递token数据,每个方法都需要验证token代码冗余,不够灵活? 如何优化\n- 使用拦截器进行优化\n```\n\n```java\n@Override\npublic boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {\n  String token = request.getHeader(\"token\");\n  Map<String,Object> map = new HashMap<>();\n  try {\n    JWTUtils.verify(token);\n    return true;\n  } catch (TokenExpiredException e) {\n    map.put(\"state\", false);\n    map.put(\"msg\", \"Token已经过期!!!\");\n  } catch (SignatureVerificationException e){\n    map.put(\"state\", false);\n    map.put(\"msg\", \"签名错误!!!\");\n  } catch (AlgorithmMismatchException e){\n    map.put(\"state\", false);\n    map.put(\"msg\", \"加密算法不匹配!!!\");\n  } catch (Exception e) {\n    e.printStackTrace();\n    map.put(\"state\", false);\n    map.put(\"msg\", \"无效token~~\");\n  }\n  String json = new ObjectMapper().writeValueAsString(map);\n  response.setContentType(\"application/json;charset=UTF-8\");\n  response.getWriter().println(json);\n  return false;\n}\n```\n\n```java\n@Component\npublic class InterceptorConfig implements WebMvcConfigurer {\n    @Override\n    public void addInterceptors(InterceptorRegistry registry) {\n        registry.addInterceptor(new JwtTokenInterceptor()).\n          excludePathPatterns(\"/user/**\")\n          .addPathPatterns(\"/**\");\n    }\n}\n```\n\n', '2021-03-02 21:10:54', 'https://cdn.jsdelivr.net/gh/zhangliyuangit/img/20210316130143.png', 2, 'Json web token (JWT), 是为了在网络应用环境间传递声明而执行的一种基于JSON的开放标准（(RFC 7519).该token被设计为紧凑且安全的，特别适用于分布式站点的单点登录（SSO）场景\n\n作者：Dearmadman\n链接：https://www.jianshu.com/p/576dbf44b2ae\n来源：简书\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。');

-- ----------------------------
-- Table structure for s_article_type
-- ----------------------------
DROP TABLE IF EXISTS `s_article_type`;
CREATE TABLE `s_article_type`  (
  `id` int(0) NOT NULL AUTO_INCREMENT COMMENT 'id',
  `article_id` int(0) NOT NULL COMMENT '文章id',
  `type_id` int(0) NOT NULL COMMENT '文章类型id',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 42 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of s_article_type
-- ----------------------------
INSERT INTO `s_article_type` VALUES (1, 1, 1);
INSERT INTO `s_article_type` VALUES (2, 1, 2);
INSERT INTO `s_article_type` VALUES (3, 2, 1);
INSERT INTO `s_article_type` VALUES (4, 3, 1);
INSERT INTO `s_article_type` VALUES (5, 4, 1);
INSERT INTO `s_article_type` VALUES (6, 5, 1);
INSERT INTO `s_article_type` VALUES (7, 6, 1);
INSERT INTO `s_article_type` VALUES (8, 7, 1);
INSERT INTO `s_article_type` VALUES (9, 4, 4);
INSERT INTO `s_article_type` VALUES (10, 5, 4);
INSERT INTO `s_article_type` VALUES (11, 6, 4);

-- ----------------------------
-- Table structure for s_attention
-- ----------------------------
DROP TABLE IF EXISTS `s_attention`;
CREATE TABLE `s_attention`  (
  `id` int(0) NOT NULL AUTO_INCREMENT COMMENT 'id',
  `be_user_id` int(0) NOT NULL COMMENT '被关注者id',
  `user_id` int(0) NOT NULL COMMENT '关注着id',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 151 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of s_attention
-- ----------------------------
INSERT INTO `s_attention` VALUES (2, 1, 3);
INSERT INTO `s_attention` VALUES (3, 1, 4);
INSERT INTO `s_attention` VALUES (4, 2, 3);
INSERT INTO `s_attention` VALUES (33, 4, 2);
INSERT INTO `s_attention` VALUES (34, 4, 2);
INSERT INTO `s_attention` VALUES (50, 2, 5);
INSERT INTO `s_attention` VALUES (149, 1, 2);
INSERT INTO `s_attention` VALUES (151, 1, 5);

-- ----------------------------
-- Table structure for s_collection
-- ----------------------------
DROP TABLE IF EXISTS `s_collection`;
CREATE TABLE `s_collection`  (
  `id` int(0) NOT NULL AUTO_INCREMENT COMMENT 'id',
  `create_time` datetime(0) NULL DEFAULT NULL COMMENT '创建时间',
  `user_id` int(0) NOT NULL COMMENT '用户id',
  `name` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT '收藏夹名臣',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 13 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of s_collection
-- ----------------------------
INSERT INTO `s_collection` VALUES (1, '2021-03-31 21:34:08', 2, 'java学习');
INSERT INTO `s_collection` VALUES (2, '2021-03-31 21:34:51', 2, 'demo');
INSERT INTO `s_collection` VALUES (3, '2021-04-02 11:46:51', 2, 'test');
INSERT INTO `s_collection` VALUES (4, '2021-04-02 11:55:12', 2, '测试');
INSERT INTO `s_collection` VALUES (5, '2021-04-02 11:55:19', 2, '测试1');
INSERT INTO `s_collection` VALUES (6, '2021-04-02 11:56:58', 2, '测试2');
INSERT INTO `s_collection` VALUES (7, '2021-04-02 11:57:10', 2, '测试3');
INSERT INTO `s_collection` VALUES (8, '2021-04-02 11:58:08', 2, '测试5');
INSERT INTO `s_collection` VALUES (9, '2021-04-02 14:37:34', 1, '测试6');
INSERT INTO `s_collection` VALUES (10, '2021-04-04 11:20:24', 2, '测试6');
INSERT INTO `s_collection` VALUES (11, '2021-04-29 10:10:00', 5, 'java学习');
INSERT INTO `s_collection` VALUES (12, '2021-04-29 10:10:07', 5, 'test1');

-- ----------------------------
-- Table structure for s_collection_content
-- ----------------------------
DROP TABLE IF EXISTS `s_collection_content`;
CREATE TABLE `s_collection_content`  (
  `id` int(0) NOT NULL AUTO_INCREMENT COMMENT 'id',
  `collection_id` int(0) NOT NULL COMMENT '收藏夹id',
  `article_id` int(0) NOT NULL COMMENT '文章id',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 123 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of s_collection_content
-- ----------------------------
INSERT INTO `s_collection_content` VALUES (63, 8, 1);
INSERT INTO `s_collection_content` VALUES (64, 7, 1);
INSERT INTO `s_collection_content` VALUES (65, 1, 1);
INSERT INTO `s_collection_content` VALUES (72, 1, 3);
INSERT INTO `s_collection_content` VALUES (73, 2, 3);
INSERT INTO `s_collection_content` VALUES (74, 4, 3);
INSERT INTO `s_collection_content` VALUES (86, 2, 10);
INSERT INTO `s_collection_content` VALUES (89, 2, 1);
INSERT INTO `s_collection_content` VALUES (91, 4, 1);
INSERT INTO `s_collection_content` VALUES (105, 2, 6);
INSERT INTO `s_collection_content` VALUES (106, 1, 6);
INSERT INTO `s_collection_content` VALUES (107, 10, 6);
INSERT INTO `s_collection_content` VALUES (108, 8, 6);
INSERT INTO `s_collection_content` VALUES (109, 7, 6);
INSERT INTO `s_collection_content` VALUES (110, 5, 6);
INSERT INTO `s_collection_content` VALUES (111, 4, 6);
INSERT INTO `s_collection_content` VALUES (112, 3, 6);
INSERT INTO `s_collection_content` VALUES (113, 6, 6);
INSERT INTO `s_collection_content` VALUES (114, 10, 4);
INSERT INTO `s_collection_content` VALUES (118, 6, 3);
INSERT INTO `s_collection_content` VALUES (121, 12, 3);
INSERT INTO `s_collection_content` VALUES (122, 11, 3);
INSERT INTO `s_collection_content` VALUES (127, 7, 9);
INSERT INTO `s_collection_content` VALUES (130, 3, 9);

-- ----------------------------
-- Table structure for s_comment
-- ----------------------------
DROP TABLE IF EXISTS `s_comment`;
CREATE TABLE `s_comment`  (
  `id` int(0) NOT NULL AUTO_INCREMENT COMMENT 'id',
  `user_id` int(0) NOT NULL COMMENT '用户id',
  `article_id` int(0) NOT NULL COMMENT '文章id',
  `create_time` datetime(0) NULL DEFAULT NULL COMMENT '创建时间',
  `context` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '评论内容',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 19 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of s_comment
-- ----------------------------
INSERT INTO `s_comment` VALUES (2, 3, 1, '2021-03-20 09:41:58', '学到了');
INSERT INTO `s_comment` VALUES (3, 4, 1, '2021-03-20 09:42:17', '麻烦加一个联系方式');
INSERT INTO `s_comment` VALUES (11, 2, 1, '2021-03-31 15:06:02', 'demo');
INSERT INTO `s_comment` VALUES (12, 2, 1, '2021-03-31 15:06:41', 'test');
INSERT INTO `s_comment` VALUES (13, 2, 2, '2021-03-31 17:32:43', '测试');
INSERT INTO `s_comment` VALUES (14, 2, 3, '2021-03-31 20:32:08', 'demo');

-- ----------------------------
-- Table structure for s_file
-- ----------------------------
DROP TABLE IF EXISTS `s_file`;
CREATE TABLE `s_file`  (
  `id` int(0) NOT NULL AUTO_INCREMENT COMMENT 'id',
  `name` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '名称',
  `create_time` datetime(0) NULL DEFAULT NULL COMMENT '创建时间',
  `user_id` int(0) NOT NULL COMMENT '用户id',
  `file_name` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT '真实文件名称',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 1 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of s_file
-- ----------------------------
INSERT INTO `s_file` VALUES (1, 'demo', '2021-04-29 14:59:07', 5, '1619679541508.pdf');
INSERT INTO `s_file` VALUES (2, '笔记', '2021-04-29 15:03:21', 5, '1619679794113.md');
INSERT INTO `s_file` VALUES (3, 'pdf测试', '2021-04-29 20:58:36', 5, '1619701096288.pdf');
INSERT INTO `s_file` VALUES (4, 'word测试', '2021-04-29 22:10:19', 5, '1619705411946.doc');
INSERT INTO `s_file` VALUES (5, 'png测试', '2021-04-29 22:10:41', 5, '1619705433936.png');
INSERT INTO `s_file` VALUES (6, 'txt测试', '2021-04-29 22:11:07', 5, '1619705460273.txt');
INSERT INTO `s_file` VALUES (7, 'java笔记', '2021-04-29 22:32:03', 2, '1619706710831.md');
INSERT INTO `s_file` VALUES (8, '测试图片', '2021-04-30 09:19:11', 2, '1619745543919.jpg');

-- ----------------------------
-- Table structure for s_like
-- ----------------------------
DROP TABLE IF EXISTS `s_like`;
CREATE TABLE `s_like`  (
  `id` int(0) NOT NULL AUTO_INCREMENT COMMENT 'id',
  `user_id` int(0) NOT NULL COMMENT '用户id',
  `article_id` int(0) NOT NULL COMMENT '文章id',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 169 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of s_like
-- ----------------------------
INSERT INTO `s_like` VALUES (66, 2, 5);
INSERT INTO `s_like` VALUES (67, 2, 4);
INSERT INTO `s_like` VALUES (100, 3, 1);
INSERT INTO `s_like` VALUES (147, 2, 10);
INSERT INTO `s_like` VALUES (152, 2, 2);
INSERT INTO `s_like` VALUES (157, 2, 7);
INSERT INTO `s_like` VALUES (158, 2, 1);
INSERT INTO `s_like` VALUES (161, 2, 3);
INSERT INTO `s_like` VALUES (163, 5, 5);
INSERT INTO `s_like` VALUES (164, 5, 1);
INSERT INTO `s_like` VALUES (168, 5, 3);
INSERT INTO `s_like` VALUES (172, 2, 9);

-- ----------------------------
-- Table structure for s_question
-- ----------------------------
DROP TABLE IF EXISTS `s_question`;
CREATE TABLE `s_question`  (
  `id` int(0) NOT NULL AUTO_INCREMENT COMMENT 'id',
  `user_id` int(0) NOT NULL COMMENT '用户id',
  `title` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '标题',
  `create_time` datetime(0) NULL DEFAULT NULL COMMENT '创建时间',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 1 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of s_question
-- ----------------------------

-- ----------------------------
-- Table structure for s_type
-- ----------------------------
DROP TABLE IF EXISTS `s_type`;
CREATE TABLE `s_type`  (
  `id` int(0) NOT NULL AUTO_INCREMENT COMMENT 'id',
  `name` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '类型名称',
  `create_time` datetime(0) NULL DEFAULT NULL COMMENT '创建时间',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 11 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of s_type
-- ----------------------------
INSERT INTO `s_type` VALUES (1, 'Java', '2021-03-07 13:49:03');
INSERT INTO `s_type` VALUES (2, '中间件', '2021-03-07 13:49:29');
INSERT INTO `s_type` VALUES (3, 'go', '2021-03-14 19:22:48');
INSERT INTO `s_type` VALUES (4, 'spring', '2021-03-14 19:23:01');

-- ----------------------------
-- Table structure for s_user
-- ----------------------------
DROP TABLE IF EXISTS `s_user`;
CREATE TABLE `s_user`  (
  `id` int(0) NOT NULL AUTO_INCREMENT COMMENT 'id',
  `name` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '姓名(非空)',
  `age` int(0) NULL DEFAULT NULL COMMENT '年龄(非空)',
  `phone` char(11) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '手机号',
  `password` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '密码',
  `brief` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT '简介',
  `create_time` datetime(0) NULL DEFAULT NULL COMMENT '创建时间',
  `update_time` datetime(0) NULL DEFAULT NULL COMMENT '最后更新时间',
  `header_pic` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT '头像地址',
  `position` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT '职位',
  `company` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT '公司',
  `home_page` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT '个人主页',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 6 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of s_user
-- ----------------------------
INSERT INTO `s_user` VALUES (1, 'siji', 20, '18625815964', '123', '第一个用户', '2021-03-07 13:33:02', '2021-03-07 13:33:05', 'https://cdn.jsdelivr.net/gh/zhangliyuangit/img/byau.jpg', NULL, NULL, NULL);
INSERT INTO `s_user` VALUES (2, '利源test', 21, '18714169517', 'liyuan611', '本站作者', '2021-03-14 19:29:37', '2021-04-16 10:53:32', 'http://192.168.2.1:9999/siji/1618541612406.jpg', '学生', '黑龙江八一农垦大学', 'https://zhangliyuanblog.club/');
INSERT INTO `s_user` VALUES (3, '小明', 30, '19725401286', '123', 'demo用户', '2021-03-14 21:38:20', '2021-03-14 21:38:23', NULL, NULL, NULL, NULL);
INSERT INTO `s_user` VALUES (4, '小王', 21, '19739776639', '123', 'test用户', '2021-03-14 21:39:31', '2021-03-14 21:39:34', NULL, NULL, NULL, NULL);
INSERT INTO `s_user` VALUES (5, '用户1616512740173', NULL, '13029905545', 'siji_1616512740173', NULL, '2021-03-23 23:19:00', NULL, NULL, NULL, NULL, NULL);

SET FOREIGN_KEY_CHECKS = 1;
